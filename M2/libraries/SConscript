import os
import os.path
import re
import subprocess
import shutil
Import('state','getState','setArchitectureState','getLibSpecific','setLibSpecific','numberSubTasks',
        'setLibSpecificStateEnvExport','setLibSpecificConfigExport','setLibSpecificMakeExport','setLibSpecificMakeInstallExport','setLibSpecificNumStages','setLibSpecificStageCommandArguments',
        'setLibSpecificStageCommand','getLibSpecificStageEnvExport','getLibSpecificConfigEnv','getLibSpecificMakeEnv','getLibSpecificMakeInstallEnv','getLibSpecificNumStages','getLibSpecificStageCommandArguments',
        'getLibSpecificStageCommand','getLibSpecificEnv','Glob','buildSettingsList')

#list of dependencies to build.
buildlibraries = set(['gc','mpir','readline','gdbm','mpfr','cddlib','glpk','nauty','4ti2','lapack','lrslib','pari','ntl','factory','cddplus','frobby','gfan','libfac','normaliz','boost','libxml2'])
linuxBuildLibraries = buildlibraries
state['linux-x86_64']['buildlibraries']=linuxBuildLibraries
state['linux-x86']['buildlibraries']=linuxBuildLibraries
state['Darwin-x86_64']['buildlibraries']=set(['gc','mpir','readline','gdbm','mpfr','cddlib','glpk','nauty','4ti2','lrslib','pari','ntl','factory','cddplus','frobby','gfan','libfac','normaliz','boost'])

dependencies = {
    'sccfiles':['gc','gdbm'],
    'dstart':['scc','libfac','pari','libxml2'],
    'm2':list(buildlibraries),
}

def downloadLibrary(architecture,mode,library):
    """
    Download library if it does not already xexist in tarpath.
    """
    from urllib2 import Request, urlopen, URLError, HTTPError
    try:
        os.makedirs('../'+state[architecture][mode]['tarpath'])
    except:
        None
    libraryFile = getLibSpecific(mode,architecture,library,'CompressedLib')
    if libraryFile is None:
        raise Exception("Compressed Lib Name is None for " + library)
    filepath = '../'+state[architecture][mode]['tarpath'] + libraryFile
    absfilepath = os.path.abspath(filepath)
    if not os.path.isfile(filepath):
        url = getLibSpecific(mode,architecture,library,'downloadPath')
        if(url is None):
            url = 'http://www.math.uiuc.edu/Macaulay2/Extra/'
        url = url + libraryFile
        print 'Downloading: ' + absfilepath + ' from ' + url
        req = Request(url)
        f = urlopen(req)
        localFile = open(absfilepath,'w')
        localFile.write(f.read())
        localFile.close()

def downloadLibraries(architecture,mode):
    """
    Download any missing libraries to be built.
    """
    for library in state[architecture]['buildlibraries']:
        downloadLibrary(architecture,mode,library)

def currentBuildPath(buildSettings):
    """
    This function returns the build path for the current buildSettings.
    """
    return "../"+buildSettings.getBuildPath()

def currentTarPath(buildSettings):
    """
    This function returns the tar path for the current mode.
    """
    return '../'+buildSettings.getTarPath()
    
def buildExistingPackages(buildSettings):
    """
    This function is responsible for building lists of existing packages.
    An existing package is one that exists in the build directory.
    """
    existingPackages = set()
    buildpath = currentBuildPath(buildSettings)
    #Make the directory if it does not already exist.
    if(not os.path.isdir(buildpath)):
       os.makedirs(buildpath)
    #Check for existing packages by looking at directories in the build path.
    for partialPath in os.listdir(buildpath):
        if(not os.path.isdir(buildpath+partialPath)):
            continue
        if(partialPath[0]=='.'):
            continue
        existingPackages.add(partialPath)
    buildSettings.setState('existingpackages',existingPackages)
    return existingPackages

def allowSystem(buildSettings,package):
    """
    Return True if the library is allowed to be provide by the system, False otherwise.
    """
    return getLibSpecific(buildSettings.mode(),buildSettings.architecture(),package,'allowsystem')
def checkLibraryCIncludes(buildSettings,package,conf):
    """
    Check if for the given build settings and package the required system C include files exist.
    Return True on success, False on failure.
    """
    includes = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),package,'systemcincludes')
    if includes is None:
        return True
    for include in includes:
        if not conf.CheckCHeader(include):
            return False
    return True
def checkLibraryCPPIncludes(buildSettings,package,conf):
    """
    Check if for the given build settings and package the required system C++ include files exist.
    Return True on success, False on failure.
    """
    includes = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),package,'systemcppincludes')
    if includes is None:
        return True
    for include in includes:
        if not conf.CheckCXXHeader(include):
            return False
    return True
def checkLibraryLibs(buildSettings,package,conf):
    """
    Check if for the given build settings and package the required system libraries exist.
    Return True on success, False on failure.
    """
    libs = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),package,'systemlibs')
    if libs is None:
        return True
    for lib in libs:
        if not conf.CheckLib(lib):
            return False
    return True
def detectBuildPackages(buildSettings):
    """
    This function detects which of available packages should be built.
    """
    if buildSettings.autoDetectLibs():
        conf = Configure(buildSettings.getEnv())
        neededPackages = set()
        for package in buildSettings.getAvailablePackageBases():
            if not allowSystem(buildSettings,package):
                neededPackages.add(package)
                continue
            available = checkLibraryCIncludes(buildSettings,package,conf) and checkLibraryCPPIncludes(buildSettings,package,conf) and checkLibraryLibs(buildSettings,package,conf)
            if not available:
                print 'Need ' + package
                neededPackages.add(package)
            else:
                print 'Found system version of ' + package
        buildSettings.setState('env',conf.Finish())
        buildSettings.setPackageBases(neededPackages)
    else:
        buildSettings.setPackageBases(buildSettings.getAvailablePackageBases())

def modeBuildEnvironments(buildSettings):
    """
    This function creates environments for the libraries to use.
    """
    env = Environment()
    env.mode = buildSettings.mode
    env.state = state
    env.buildSettings = buildSettings
    buildSettings.setState('env',env)

def extractPackageName(package):
    """
    This function extracts the package name from a file.
    This is the file name minus the extension.
    """
    package = package.replace('.tar.gz','')
    package = package.replace('.tar.bz2','')
    package = package.replace('.tgz','')
    package = package.replace('.zip','')
    return package

def extractPackageBaseName(package):
    """
    This extracts the package base name from a file.
    This is the beginning of the file name up to the first non-alpha numeric character.
    """
    if(package.find('nauty')==0):
        return 'nauty'
    if(package.find('gfan')==0):
        return 'gfan'
    if(package.find('cdd+')==0):
        return 'cddplus'
    if(package.find('Normaliz')==0):
        return 'normaliz'
    return re.match('\A[0-9,a-z,A-Z]+',package).group(0)

def untarLibrary(buildSettings, source, libraryName, libraryBaseName):
   """
   This untars the library if the appropriate state flags are set.
   Source is the source file.
   """
   print 'untar library ' + libraryName
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = buildSettings.getBuildPath()
   #realpath is the path to extract to.
   realpath = buildpath+libraryName+'/'
   #Check to see if it has already been extracted.
   if(not os.path.isdir(realpath)):
      #If not, copy the tarball and extract it.
       shutil.copy(source,buildpath)
       tarp = subprocess.Popen(['tar', '-xvf',sourceFile],cwd=buildpath)
       if(tarp.wait()):
           unzipp = subprocess.Popen(['unzip', '-x',sourceFile],cwd=buildpath)
           if(unzipp.wait()):
               raise Exception("Unable to decompress " + libraryName + ".")
       buildSettings.setLibSpecific(libraryBaseName,'stage0',True)
       tarfolder = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBaseName,'tarfolder')
       if tarfolder:
           shutil.move(buildpath+tarfolder,realpath)
       patchfile = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBaseName,'patchfile')
       if patchfile is None:
           return True
       patchargs = ['patch','-p1','--input='+patchfile]
       print "Patching " + str(patchargs)
       patchp = subprocess.Popen(patchargs,cwd=realpath)
       if(patchp.wait()):
           raise Exception("Unable to patch " + libraryBaseName + " " + libraryName + " in " + realpath)
       return True
   else:
       return False

def transferEnv(env,mode,architecture,library,attr):
   """
   If the given library specific attribute exists for the given mode and architecture, set it in the env dictionary
   """
   s = getLibSpecific(mode,architecture,library,attr)
   if(s):
       env[attr]=s
def appendEnv(env,attr,val):
    """
    Append the given enviroment variable onto the existing enviroment variable in a reasonable way.
    """
    if(env.get(attr)!=None):
        env[attr] = env[attr]+' '+ val
    else:
        env[attr]=val

def executeStageLibrary(buildSettings,source,packageName,libraryBaseName,stage,diroffset=None):
   #Source file is the file name of the tarball.
   sourceFile = os.path.split(source)[1]
   #Buildpath is the build directory
   buildpath = buildSettings.getBuildPath()
   #realpath is the path to extract to.
   realpath = buildpath+packageName+'/'
   buildDirectory = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBaseName,'builddirectory')
   if(buildDirectory):
       realpath = realpath+buildDirectory
   stageoffset = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBaseName,'stage'+str(stage)+'DirOffset')
   if(stageoffset):
       realpath = realpath + stageoffset
   if(diroffset):
       realpath = realpath+diroffset
   if(buildSettings.getLibSpecific(libraryBaseName,'stage'+str(stage),False) is True):
       cmd = getLibSpecificStageCommand(buildSettings,libraryBaseName,stage)
       if(cmd==''):
           return
       args = getLibSpecificStageCommandArguments(buildSettings,libraryBaseName,stage)
       if(cmd!='make'):
           args = [os.path.abspath(realpath+cmd)]+args
       else:
           args = [cmd]+args
       newEnv = os.environ
       getLibSpecificEnv(buildSettings,libraryBaseName,stage,newEnv)
       print 'Execute: ' + str(args) + " in " + realpath
       proc = subprocess.Popen(args,cwd=realpath,env=newEnv)
       if(proc.wait()):
           if(cmd=='bjam'):
               None
           else:
               raise Exception("Unable to execute " + str(args) + " for library " + packageName + " in " + realpath)
       buildSettings.setLibSpecific(libraryBaseName,'stage'+str(stage+1),True)       
       return True
   else:
       return False
    
def configureLibrary(buildSettings, source, packageName, libraryBaseName):
   """
   Configure the given library
   """
   return executeStageLibrary(buildSettings,source,packageName,libraryBaseName,0)

def makeLibrary(buildSettings, source, packageName, libraryBaseName, diroffset = None):
   """
   Make the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   return executeStageLibrary(buildSettings,source,packageName,libraryBaseName,1,diroffset)

def makeInstallLibrary(buildSettings, source, libraryName, libraryBaseName, diroffset = None):
   """
   Install the given library
   Note that we use popen instead of system because we are not allowed to chdir.
   """
   return executeStageLibrary(buildSettings,source,libraryName,libraryBaseName,2,diroffset)

def deepCleanLibrary(buildSettings, packageBaseName):
    """
    Deep clean the given library.
    This removes the existing directory so the tarball will be reextracted
    """
    if buildSettings.shouldDeepCleanLib(packageBaseName):
        existingPackages = buildSettings.getExistingPackages()
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Deleting build directory for: ' + packageBaseName + ' at ' + directory
                Execute(Delete(directory))
        buildSettings.setLibSpecific(packageBaseName,'stage0',True)
        return True
    else:
        return False
   
def cleanLibrary(buildSettings, packageBaseName):
    """
    Clean the given library.
    This is equivalent to make clean.
    """
    if buildSettings.shouldCleanLib(packageBaseName):
        existingPackages = buildSettings.getExistingPackages()
        for existing in existingPackages:
            if(extractPackageBaseName(existing)==packageBaseName):
                directory = getState(mode,architecture,'buildpath') + existing
                print 'Cleaning ' + packageBaseName + ' at ' + directory
                cleanp = subprocess.Popen(['make','clean'],cwd=directory)
                if(cleanp.wait()):
                    raise Exception("Unable to clean " + packageBaseName)
                buildSettings.setLibSpecific(packageBaseName,'stage1',True)
        return True
    else:
        return False
    
#This holds a set of SConscripts that have already been imported.
importedSConscripts = set()

def modeImportSConscript(buildSettings):
    """
    This function imports SConscripts for packages.
    """
    packageBases = buildSettings.getAvailablePackageBases()
    for package in packageBases:
        package = extractPackageBaseName(package)
        if(not package in importedSConscripts):
            SConscript(package+'/SConscript',exports={
                    'numberSubTasks':numberSubTasks,
                    'extractPackageName':extractPackageName,
                    'extractPackageBaseName':extractPackageBaseName,
                    'getLibSpecific':getLibSpecific,
                    'setLibSpecific':setLibSpecific,
                    'untarLibrary':untarLibrary,
                    'transferEnv':transferEnv,
                    'configureLibrary':configureLibrary,
                    'makeLibrary':makeLibrary,
                    'makeInstallLibrary':makeInstallLibrary,
                    'deepCleanLibrary':deepCleanLibrary,
                    'cleanLibrary':cleanLibrary,
                    'setLibSpecificStateEnvExport':setLibSpecificStateEnvExport,
                    'setLibSpecificConfigExport':setLibSpecificConfigExport,
                    'setLibSpecificMakeExport':setLibSpecificMakeExport,
                    'setLibSpecificMakeInstallExport':setLibSpecificMakeInstallExport,
                    'setLibSpecificNumStages':setLibSpecificNumStages,
                    'setLibSpecificStageCommandArguments':setLibSpecificStageCommandArguments,
                    'setLibSpecificStageCommand':setLibSpecificStageCommand,
                    'getLibSpecificStageEnvExport':getLibSpecificStageEnvExport,
                    'getLibSpecificConfigEnv':getLibSpecificConfigEnv,
                    'getLibSpecificMakeEnv':getLibSpecificMakeEnv,
                    'getLibSpecificMakeInstallEnv':getLibSpecificMakeInstallEnv,
                    'getLibSpecificNumStages':getLibSpecificNumStages,
                    'getLibSpecificStageCommandArguments':getLibSpecificStageCommandArguments,
                    'getLibSpecificStageCommand':getLibSpecificStageCommand,
                    'defaultCleanLibrary':defaultCleanLibrary,
                    'executeStageLibrary':executeStageLibrary,
                    'buildBuilders':buildBuilders,
                    'installBuilders':installBuilders,
                    })
            importedSConscripts.add(package)
            deps = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),package,'Dependencies')
            if deps:
                dependencies[package]=deps

    
def safemakedirs(path):
    try:
        os.makedirs(path)
    except OSError:
        None

def modeSpecific1(buildSettings):
    """
    This is the first call to set up libraries for the various buildSettings.
    """
    #Create default directories.
    safemakedirs(os.path.abspath('../'+buildSettings.getPrefixPath()+'lib/'))
    safemakedirs(os.path.abspath('../'+buildSettings.getPrefixPath()+'include/'))
    buildSettings.setAvailablePackageBases(state[buildSettings.architecture()]['buildlibraries'])
    #Build existing packages list (for cleaning).
    buildExistingPackages(buildSettings)
    #Build SCons Environments.
    modeBuildEnvironments(buildSettings)

def modeSpecific2(buildSettings):
    """
    This is the second call to set up libraries for the various buildSettings.
    """
    #Import library sconscript files.
    modeImportSConscript(buildSettings)
    detectBuildPackages(buildSettings)
    #Download libraries if necessary
    if state['enabledownload']:
        downloadLibraries(architecture,mode)

def buildCandidates(buildSettings):
    """
    This function assembles a list of build candidates.
    In the event of multiple files for the same library, the newest by creation date is used.
    """
    packages = [getLibSpecific(buildSettings.mode(),buildSettings.architecture(),library,'CompressedLib') for library in buildSettings.getPackageBases()]
    existingPackages = buildSettings.getExistingPackages()
    tarpath = "../"+buildSettings.getTarPath()
    doBuildLibraries = {}
    for package in packages:
        libraryBaseName = extractPackageBaseName(package)
        if(libraryBaseName in buildSettings.getPackageBases()):
            existingPackage = doBuildLibraries.get(libraryBaseName)
            if(existingPackage is not None):
                if(os.path.getmtime(tarpath+existingPackage) < os.path.getmtime(tarpath+package)):
                    doBuildLibraries[libraryBaseName]=package
            else:
                doBuildLibraries[libraryBaseName]=package
    return doBuildLibraries

def defaultCleanLibrary(buildSettings,packageBaseName):
    """
    Default function that gets called to process a clean library command
    """
    if(deepCleanLibrary(buildSettings,libraryName)):
        return True
    if(cleanLibrary(buildSettings,libraryName)):
        return True   
    return False

def defaultBuildLibrary(target,source,env):
    """
    Build target for the library.
    """
    source = source[0].rstr()
    sourceFile = os.path.split(source)[1]
    packageName = extractPackageName(sourceFile)
    buildSettings = env.buildSettings
    libraryName = extractPackageBaseName(packageName)
    cleaned = defaultCleanLibrary(buildSettings,libraryName)
    if getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryName,'DecompressLib') is True:
        untarLibrary(buildSettings,source, packageName, libraryName)
    numstages = getLibSpecificNumStages(buildSettings.mode(),buildSettings.architecture(),libraryName)
    for i in range(0,numstages):
        executeStageLibrary(env.buildSettings,source,packageName,libraryName,i)
    return None            

def installBuilders(buildFunc, libraryName):
    """
    Install buildFunc as the builders for libraryName
    """
    for buildSettings in buildSettingsList:
        builder = Builder(action=buildFunc, single_source=1)
        buildSettings.getEnv().Append(BUILDERS = {'build_'+libraryName : builder})
        buildSettings.getBuilders()[libraryName]=builder
    
def buildBuilders(libraryName):
    """
    Build build functions for the given library.
    """
    installBuilders(defaultBuildLibrary,libraryName)

def createBuilders(buildSettings,libraryBase,builders):
    library = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBase,'CompressedLib')
    source = '../'+buildSettings.getTarPath()+library
    builder = buildSettings.getEnv().__dict__['build_'+libraryBase](builddir+library,source)
    builders[libraryBase] = builder
    AlwaysBuild(builder)
    buildSettings.setLibSpecific(libraryBase,'stage0',True)
    #recursively rebuild library dependencies.
    for dlibrary,deps in dependencies.items():
        if not dlibrary in buildSettings.getPackageBases():
            continue
        if libraryBase in deps:
            if not builders.has_key(dlibrary):
                createBuilders(buildSettings,dlibrary,builders)
    

#Setup the various modes.
for buildSettings in buildSettingsList:
    modeSpecific1(buildSettings)
for buildSettings in buildSettingsList:
    modeSpecific2(buildSettings)
    builders = {}
    builders['dstart'] = buildSettings.getState('dstart')
    builders['scc'] = buildSettings.getState('scc')
    builders['sccfiles'] = buildSettings.getState('sccfiles')
    builders['m2']=buildSettings.getState('m2')
    dbl = buildCandidates(buildSettings)
    for libraryBase,library in dbl.items():
        libraryName = extractPackageName(library)
        builddir = '../'+buildSettings.getBuildPath()
        source = '../'+buildSettings.getTarPath()+library
        build = False
        for f in getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBase,'InstallFiles'):
            prefixpath = buildSettings.getPrefixPath()
            f = f.replace("$SConsInstallPrefixPath",os.path.abspath('../'+prefixpath))
            if not os.path.exists(f):
                print 'Unable to find: ' + f + ' for ' + libraryBase
                build = True
        if(buildSettings.shouldDeepCleanLib(libraryBase) or buildSettings.shouldCleanLib(libraryBase)):
            build=True
        if build:
            createBuilders(buildSettings,libraryBase,builders)

    for target, tdependencies in dependencies.items():
        if not builders.has_key(target):
            continue
        btarget = builders[target]
        if(type(tdependencies) is list):
            if(type(btarget) is list):
                for bltarget in btarget:
                    for dependency in tdependencies:
                        if(builders.has_key(dependency)):
                            Requires(bltarget,builders[dependency])
            else:
                for dependency in tdependencies:
                    if(builders.has_key(dependency)):
                        Requires(btarget,builders[dependency])                
        else:
            if(builders.has_key(tdependency)):
                Requires(btarget,builders[tdependencies])





