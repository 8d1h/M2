import os.path
import shutil
import subprocess
Import('state','extractPackageName','extractPackageBaseName','getLibSpecific','setLibSpecific','getState','setState','untarLibrary','transferEnv',
       'configureLibrary','makeLibrary','makeInstallLibrary','deepCleanLibrary','cleanLibrary','architecture',
       'setLibSpecificStateEnvExport','setLibSpecificConfigExport','setLibSpecificMakeExport','setLibSpecificMakeInstallExport','setLibSpecificNumStages','setLibSpecificStageCommandArguments',
       'setLibSpecificStageCommand','getLibSpecificStageEnvExport','getLibSpecificConfigEnv','getLibSpecificMakeEnv','getLibSpecificMakeInstallEnv','getLibSpecificNumStages','getLibSpecificStageCommandArguments',
       'getLibSpecificStageCommand','executeStageLibrary')

#set this to library name
libraryName = 'gc'
#Library specific declarations go here.
setLibSpecificConfigExport('release',['linux-x86','linux-x86_64'],libraryName,'CFLAGS','-g -O2')
setLibSpecificConfigExport('debug',['linux-x86','linux-x86_64'],libraryName,'CFLAGS','-g -O0')
setLibSpecificConfigExport('all',['linux-x86','linux-x86_64'],libraryName,'CPPFLAGS','-I$SConsInstallPrefixPath/include/')
setLibSpecificConfigExport('all',['linux-x86','linux-x86_64'],libraryName,'LDFLAGS','-L$SConsInstallPrefixPath/lib/')
setLibSpecificConfigExport('all',['linux-x86','linux-x86_64'],libraryName,'CC','gcc')
setLibSpecificConfigExport('all',['linux-x86','linux-x86_64'],libraryName,'CXX','g++')
setLibSpecificStageCommandArguments('all',['linux-x86','linux-x86_64'],libraryName,0,['--enable-threads=posix','--enable-parallel-mark','--disable-shared','--enable-large-config','--disable-gcj-support','--disable-java-finalization', '--prefix=$SConsInstallPrefixPath'])

setLibSpecificStateEnvExport('release',['linux-x86','linux-x86_64'],libraryName,3,'CFLAGS','-g -O2')
setLibSpecificStateEnvExport('debug',['linux-x86','linux-x86_64'],libraryName,3,'CFLAGS','-g -O0')
setLibSpecificStateEnvExport('all',['linux-x86','linux-x86_64'],libraryName,3,'CPPFLAGS','-I$SConsInstallPrefixPath/include/')
setLibSpecificStateEnvExport('all',['linux-x86','linux-x86_64'],libraryName,3,'LDFLAGS','-L$SConsInstallPrefixPath/lib/')
setLibSpecificStateEnvExport('all',['linux-x86','linux-x86_64'],libraryName,3,'CC','gcc')
setLibSpecificStateEnvExport('all',['linux-x86','linux-x86_64'],libraryName,3,'CXX','g++')
setLibSpecificStageCommandArguments('all',['linux-x86','linux-x86_64'],libraryName,3,['--prefix=$SConsInstallPrefixPath'])
setLibSpecificStageCommandArguments('all',['linux-x86','linux-x86_64'],libraryName,5,['install'])
setLibSpecificStageCommand('all',['linux-x86','linux-x86_64'],libraryName,3,'configure')
setLibSpecificStageCommand('all',['linux-x86','linux-x86_64'],libraryName,4,'make')
setLibSpecificStageCommand('all',['linux-x86','linux-x86_64'],libraryName,5,'make')

   
def BuildLibrary(target,source,env):
   """
   Build target for the library.
   """
   source = source[0].rstr()
   sourceFile = os.path.split(source)[1]
   packageName = extractPackageName(sourceFile)
   cleaned = CleanLibrary(env.mode,architecture,libraryName)
   untarLibrary(env.state,env.mode,architecture,source, packageName, libraryName)
   configureLibrary(env.state,env.mode,architecture,source,packageName,libraryName)
   makeLibrary(env.state,env.mode,architecture,source,packageName,libraryName)
   makeInstallLibrary(env.state,env.mode,architecture,source,packageName,libraryName)
   executeStageLibrary(env.state,env.mode,architecture,source,packageName,libraryName,3,'libatomic_ops/')
   executeStageLibrary(env.state,env.mode,architecture,source,packageName,libraryName,4,'libatomic_ops/')
   executeStageLibrary(env.state,env.mode,architecture,source,packageName,libraryName,5,'libatomic_ops/')
   return None

def CleanLibrary(mode,directory,packageBaseName):
   """
   Actual function that gets called to process a clean library command
   """
   if(deepCleanLibrary(mode,architecture,libraryName)):
      return True
   if(cleanLibrary(mode,architecture,libraryName)):
      return True   
   return False

for mode in state[architecture]['modes']:
   if(getState(mode,architecture,'build')):
      builder = Builder(action=BuildLibrary, single_source=1)
      getState(mode,architecture,'env').Append(BUILDERS = {'build_'+libraryName : builder})
      if(state[architecture][mode].get('builders')==None):
         setState(mode,architecture,'builders',{})
      getState(mode,architecture,'builders')[libraryName]=builder

