defaultModes = 'debug'
AddOption('--deepcleanlib',dest='deepcleanlib',nargs=1,action='store',type='string',help='Remove all libraries or the specified library only')
AddOption('--cleanlib',dest='cleanlib',nargs=1,action='store',type='string',help='Clean all libraries or the specified library only')
AddOption('--configlib',dest='configlib',nargs=1,action='store',type='string',help='Reconfigure and remake the specified library only')
AddOption('--makelib',dest='makelib',nargs=1,action='store',type='string',help='Remake the specified library only')
AddOption('--modes',dest='modes',nargs=1,action='store',type='string',default='release,debug',help='One or more modes to build separated by commas.  Defaults to ' + defaultModes)
AddOption('--jj',dest='jj',nargs=1,action='store',type='int',default='1',help='Number of parallel sub-tasks to run for each build task')
AddOption('--disable-parallel',dest='disableparallel',nargs=0,action='store',help='Disable parallel build')

state = {
    'linux-x86_64':
        {
        'debug':{
            'prefixpath':'local/',
            'includepath':'local/debug/include/',
            'libpath':'local/debug/lib',
            'buildpath':'BUILD/debug/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{ }
            },
        'release':{
            'prefixpath':'local/',
            'includepath':'local/release/include/',
            'libpath':'local/release/lib/',
            'buildpath':'BUILD/release/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{}
            },
        'modes':set(['debug','release']),
        },
    'linux-x86':
        {
        'debug':{
            'prefixpath':'local/',
            'includepath':'local/debug/include/',
            'libpath':'local/debug/lib/',
            'buildpath':'BUILD/debug/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{ }
            },
        'release':{
            'prefixpath':'local/',
            'includepath':'local/release/include/',
            'libpath':'local/release/lib/',
            'buildpath':'BUILD/release/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{}
            },
        'modes':set(['debug','release']),
        },
    'architectures':['linux-x86_64','linux-x86'],
    'build':True,
    'clean':False
}

def getState(mode,architecture,attribute,exception=True):
    """
    This returns the attribute requested for the given mode and architecture.
    """
    if(mode == None or architecture == None or attribute == None):
        raise Exception("Invalid arguments to getState")
    adict = state.get(architecture)
    if(adict == None):
        raise KeyError("Unknown architecture: " + architecture)
    mdict = adict.get(mode)
    if(mdict == None):
        raise KeyError("Unknown mode: " + mode)
    value = mdict.get(attribute)
    if(value is None):
        if(exception):
            raise KeyError("Unknown attribute: " + attribute)
    return value

def setState(mode,architecture,attribute,value):
    """
    This sets the attribute to the value for the given mode and architecture.
    """
    if(mode == None or architecture == None or attribute == None):
        raise Exception("Invalid arguments to getState")
    adict = state.get(architecture)
    if(adict == None):
        raise KeyError("Unknown architecture: " + architecture)
    mdict = adict.get(mode)
    if(mdict == None):
        raise KeyError("Unknown mode: " + mode)
    mdict[attribute] = value

def getLibSpecific(mode,architecture,libraryBaseName,attribute):
    """
    Get the library specific attribute for the given library, mode, and architecture.
    """
    if(libraryBaseName == None or attribute == None):
        raise Exception("Invalid arguments to getLibSpecific")

    try:
        libspecific = getState(mode,architecture,'libspecific')[libraryBaseName][attribute]
    except KeyError, e:
        return None
    return libspecific
    
def setLibSpecific(mode,architecture,libraryBaseName,attribute,value):
    """
    This sets the given attribute for the given mode and architecture.
    """
    if(type(architecture)==list):
        for arch in architecture:
            setLibSpecific(mode,arch,libraryBaseName,attribute,value)
        return
    elif(architecture=='all'):
        for arch in state['architectures']:
            setLibSpecific(mode,arch,libraryBaseName,attribute,value)
        return
    elif(mode=='all'):
        for lmode in state[architecture]['modes']:
            setLibSpecific(lmode,architecture,libraryBaseName,attribute,value)
        return
    if(libraryBaseName == None or attribute == None):
        raise Exception("Invalid arguments to getLibSpecific")
    try:
        libspecific = getState(mode,architecture,'libspecific')
    except KeyError:
        libspecific = state[architecture][mode]['libspecific']={}
    try:
        llspec = libspecific[libraryBaseName]
    except:
        llspec = libspecific[libraryBaseName] = { }
    llspec[attribute]=value

def setLibSpecificConfigExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Sets a library specific make export
    """
    makeenv = getLibSpecific(mode,architecture,libraryBaseName,'config env')
    if(libspecific is None):
        makeenv = setLibSpecific(mode,architecture,libraryBaseName,'config env')
    makeenv[attribute]=value

def setLibSpecificMakeExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Sets a library specific make export
    """
    makeenv = getLibSpecific(mode,architecture,libraryBaseName,'make env')
    if(libspecific is None):
        makeenv = setLibSpecific(mode,architecture,libraryBaseName,'make env')
    makeenv[attribute]=value

def setLibSpecificMakeInstallExport(mode,architecture,libraryBaseName,attribute,value):
    makeenv = getLibSpecific(mode,architecture,libraryBaseName,'make env')
    if(libspecific is None):
        makeenv = setLibSpecific(mode,architecture,libraryBaseName,'make install env')
    makeenv[attribute]=value

def  determineNumberOfCPUs():
    """
    Number of virtual or physical CPUs on this system, i.e.
    user/real as output by time(1) when called with an optimally scaling
    userspace-only program
    See: http://stackoverflow.com/questions/1006289/how-to-find-out-the-number-of-cpus-in-python
    """
    import os,re,subprocess
    # Python 2.6+
    try:
        import multiprocessing
        return multiprocessing.cpu_count()
    except (ImportError,NotImplementedError):
        pass

    # POSIX
    try:
        res = int(os.sysconf('SC_NPROCESSORS_ONLN'))

        if res > 0:
            return res
    except (AttributeError,ValueError):
        pass

    # Windows
    try:
        res = int(os.environ['NUMBER_OF_PROCESSORS'])

        if res > 0:
            return res
    except (KeyError, ValueError):
        pass

    # BSD
    try:
        sysctl = subprocess.Popen(['sysctl', '-n', 'hw.ncpu'],
                                      stdout=subprocess.PIPE)
        scStdout = sysctl.communicate()[0]
        res = int(scStdout)

        if res > 0:
            return res
    except (OSError, ValueError):
        pass

    # Linux
    try:
        res = open('/proc/cpuinfo').read().count('processor\t:')

        if res > 0:
            return res
    except IOError:
        pass

    # Solaris
    try:
        pseudoDevices = os.listdir('/devices/pseudo/')
        expr = re.compile('^cpuid@[0-9]+$')

        res = 0
        for pd in pseudoDevices:
            if expr.match(pd) != None:
                res += 1

        if res > 0:
            return res
    except OSError:
        pass

    # Other UNIXes (heuristic)
    try:
        try:
            dmesg = open('/var/run/dmesg.boot').read()
        except IOError:
            dmesgProcess = subprocess.Popen(['dmesg'], stdout=subprocess.PIPE)
            dmesg = dmesgProcess.communicate()[0]

        res = 0
        while '\ncpu' + str(res) + ':' in dmesg:
            res += 1

        if res > 0:
            return res
    except OSError:
        pass

    return 1

#Number of cores.  Use this for autoscaling.
numCore = determineNumberOfCPUs()
#Number of subtasks
numSubTasks = numCore

def numberSubTasks():
    """
    Return the number of parallel make subtasks allowed.
    """
    return numSubTasks

#Number of parallel jobs
numJobs = determineNumberOfCPUs()

def numberJobs():
    """
    Return the number of jobs the build is using
    """
    return numJobs

#Original number of jobs (-j parameter)
originalNumJobs = GetOption('num_jobs')
#Set appropriate auto parallel settings.
if(GetOption('disableparallel') is not None):
    print 'Parallel build disabled'
    numJobs = 1
    numSubTasks = 1
elif originalNumJobs==1:
    SetOption('num_jobs', numCore)
    print 'Autodetected ' + str(numCore) + ' CPUs.'
else:
    numJobs = originalNumJobs
#If the user requested to specify number of subtasks, do it.
if(GetOption('jj')):
    numSubTasks=GetOption('jj')


#Set the state based on if clean was requested.
if(GetOption('clean')!=None):
    state['build']=False
    state['clean']=True
#Current architecture to build under.
architecture = 'linux-x86_64'
#Requested build modes.
modes = GetOption('modes')
#List of modes requested to build.
splitModes = modes.split(',')
for mode in splitModes:
    try:
        setState(mode,architecture,'build',True)
        #handle clean lib
        if(GetOption('cleanlib')!=None):
            if(GetOption('cleanlib')=='all'):
                setState(mode,architecture,'cleanlib',True)
            else:
                splitCleanLib = GetOption('cleanlib').split(',')
                for s in splitCleanLib:
                    setLibSpecific(mode,architecture,s,'clean',True)
        #handle deep clean
        if(GetOption('deepcleanlib')!=None):
            if(GetOption('deepcleanlib')=='all'):
                setState(mode,architecture,'deepcleanlib',True)
            else:
                splitDeepCleanLib = GetOption('deepcleanlib').split(',')
                for s in splitDeepCleanLib:
                    setLibSpecific(mode,architecture,s,'deepclean',True)
        #handle configlib
        if(GetOption('configlib')!=None):
            if(GetOption('configlib')=='all'):
                setState(mode,architecture,'configlib',True)
            else:
                splitConfigLib = GetOption('configlib').split(',')
                for s in splitConfigLib:
                    setLibSpecific(mode,architecture,s,'config',True)            
        #handle makelib
        if(GetOption('makelib')!=None):
            if(GetOption('makelib')=='all'):
                setState(mode,architecture,'makelib',True)
            else:
                splitMakeLib = GetOption('makelib').split(',')
                for s in splitMakeLib:
                    setLibSpecific(mode,architecture,s,'make',True)            
    except KeyError:
        raise Exception('Unknown mode: "' + mode + '"')

SConscript('libraries/SConscript',exports=
           {
        'state':state,
        'getLibSpecific':getLibSpecific,
        'setLibSpecific':setLibSpecific,
        'getState':getState,
        'setState':setState,
        'architecture':architecture,
        'numberJobs':numberJobs,
        'numberSubTasks':numberSubTasks,
        })
#SConscript('Macaulay2/SConscript',exports={'state':state})

