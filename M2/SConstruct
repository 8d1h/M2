import os.path
defaultModes = 'debug'
AddOption('--deepcleanlib',dest='deepcleanlib',nargs=1,action='store',type='string',help='Remove all libraries or the specified library only')
AddOption('--cleanlib',dest='cleanlib',nargs=1,action='store',type='string',help='Clean all libraries or the specified library only')
AddOption('--configlib',dest='configlib',nargs=1,action='store',type='string',help='Reconfigure and remake the specified library only')
AddOption('--makelib',dest='makelib',nargs=1,action='store',type='string',help='Remake the specified library only')
AddOption('--modes',dest='modes',nargs=1,action='store',type='string',default='release,debug',help='One or more modes to build separated by commas.  Defaults to ' + defaultModes)
AddOption('--jj',dest='jj',nargs=1,action='store',type='int',help='Number of parallel sub-tasks to run for each build task')
AddOption('--disable-parallel',dest='disableparallel',nargs=0,action='store',help='Disable parallel build')
AddOption('--enable-download',dest='enabledownload',nargs=0,action='store',help='Disable downloading packages')
AddOption('--distribution',dest='distribution',type='string',nargs=1,action='store',default='Source-System',help='Distribution to build.  Defaults to "Source-System"')

debugGCCEFlags = debugGCCM2Flags = debugGCCFlags = '-O0 -g'
releaseGCCEFlags = releaseGCCM2Flags = releaseGCCFlags = '-O2 -g'

state = {
    'Darwin-x86_64':
        {
        'debug':{
            'libspecific':{ },
            'eflags':debugGCCEFlags,
            'M2flags':debugGCCM2Flags,
            },
        'release':{
            'libspecific':{},
            'eflags':releaseGCCEFlags,
            'M2flags':releaseGCCM2Flags,
            },
        'modes':set(['debug','release']),
        },
    'Darwin-x86':
        {
        'debug':{
            'libspecific':{ },
            'eflags':debugGCCEFlags,
            'M2flags':debugGCCM2Flags,
            },
        'release':{
            'libspecific':{},
            'eflags':releaseGCCEFlags,
            'M2flags':releaseGCCM2Flags,
            },
        'modes':set(['debug','release']),
        },
    'linux-x86_64':
        {
        'debug':{
            'libspecific':{ },
            'eflags':debugGCCEFlags,
            'M2flags':debugGCCEFlags,
            },
        'release':{
            'libspecific':{},
            'eflags':releaseGCCEFlags,
            'M2flags':releaseGCCM2Flags,
            },
        'modes':set(['debug','release']),
        },
    'linux-x86':
        {
        'debug':{
            'libspecific':{ },
            'eflags':debugGCCEFlags,
            'M2flags':debugGCCM2Flags,
            },
        'release':{
            'libspecific':{},
            'eflags':releaseGCCEFlags,
            'M2flags':releaseGCCM2Flags,
            },
        'modes':set(['debug','release']),
        },
    'architectures':['linux-x86_64','linux-x86','Darwin-x86_64'],
    'build':True,
    'clean':False,
    'enabledownload':False
}
class BuildSettings:
    """
    This class encapsulates the unique idenitfing information for a given possible build.
    These are:
    Mode (debug or release),
    Architecture (linux-x86, Darwin-x86_64, etc),
    Distribution Type (Source, Fedora, Ubuntu, etc)
    """
    def __init__(self,architecture,mode,distributionType):
        self._mode = mode
        self._architecture = architecture
        self._distributionType = distributionType
        self._autoDetectLibs = True
        self._state={}
        self._builders = {}
        self._libSpecific = {}
    def mode(self):
        return self._mode
    def architecture(self):
        return self._architecture
    def distributionType(self):
        return self._distributionType
    def packageVersion(self):
        return "1.4.0.1"
    def packages(self):
        return ""
    def autoDetectLibs(self):
        """
        Return True if should auto detect which libraries to build, false otherwise.
        """
        return self._autoDetectLibs
    def setAutoDetectLibs(self, autoDetectLibs):
        """
        Set auto detection of libraries to true to enable, false to disable.
        """
        if(type(autoDetectLibs)!=bool):
            raise TypeException("autoDetectLibs must be true or false")
        self._autoDetectLibs = autoDetectLibs
    def setAvailablePackageBases(self,packageBases):
        self._availablePackageBases = packageBases
    def setPackageBases(self,packageBases):
        self._packageBases = packageBases
    def getExistingPackages(self):
        return self._state['existingpackages']
    def getPackageBases(self):
        return self._packageBases
    def getAvailablePackageBases(self):
        return self._availablePackageBases
    def getM2Flags(self):
        return getStateMode(self._mode,self._architecture,'M2flags')
    def getEnv(self):
        return self._state['env']
    def getBuilders(self):
        return self._builders
    def getPrefixPath(self):
        return self._state['prefixpath']
    def getBuildPath(self):
        return self._state['buildpath']
    def getTarPath(self):
        return 'BUILD/tarfiles/'
    def getState(self,attribute,throwException=True):
        if(throwException):
            return self._state[attribute]
        try:
            return self._state[attribute]
        except:
            return None
    def setState(self,attribute,val):
        self._state[attribute]=val
    def setLibSpecific(self,libraryName,attribute,val):
        try:
            d = self._libSpecific[libraryName]
        except KeyError:
            d = {}
            self._libSpecific[libraryName]=d
        d[attribute]=val
    def getLibSpecific(self,libraryName,attribute,throwException=True):
        if(throwException):
            return self._libSpecific[libraryName][attribute]
        try:
            return self._libSpecific[libraryName][attribute]
        except KeyError:
            return None
    def shouldDeepCleanLib(self,libraryName):
        return (self.getState('deepclean',False) == True) or (self.getLibSpecific(libraryName,'deepcleanlib',False)==True)
    def shouldCleanLib(self,libraryName):
        return (self.getState('cleanlib',False) == True) or (self.getLibSpecific(libraryName,'cleanlib',False)==True)
    
def detectArchitecture():
    """
    Return detected architecture of currently running operating system & CPU architecture as string.
    """
    import platform
    if platform.system()=='Linux':
        if platform.architecture()[0]=='64bit':
            return 'linux-x86_64'
        elif platform.architecture()[0]=='32bit':
            return 'linux-x86'
        else:
            raise NotImplementedError("Unknown linux architecture %s" % architecture)
    elif platform.system()=='Darwin':
        if platform.architecture()[0]=='64bit':
            return 'Darwin-x86_64'
        elif platform.architecture()[0]=='32bit':
            raise NotImplementedError("Darwin-x86 unsupported")
            return 'Darwin-x86'
        else:
            raise NotImplementedError("Unknown Darwin architecture %s" % architecture)
    elif platform.system()=='nt':
        if platform.architecture()[0]=='64bit':
            return 'nt-x86_64'
        elif platform.architecture()[0]=='32bit':
            return 'nt-x86'
        else:
            raise NotImplementedError("Unknown NT architecture %s" % architecture)
    else:
        raise NotImplementedError("Unknown NT architecture %s" % architecture)

def getState(buildSettings,attribute,exception=True):
    """
    This returns the attribute requested for the given mode and architecture.
    """
    if(buildSettings is None or (not isinstance(buildSettings,BuildSettings)) or attribute is None):
        raise Exception("Invalid arguments to getState %s %s",str(buildSettings),attribute)
    adict = state.get(buildSettings.architecture())
    if(adict == None):
        raise KeyError("Unknown architecture: " + architecture)
    mdict = adict.get(buildSettings.mode())
    if(mdict == None):
        raise KeyError("Unknown mode: " + mode)
    value = mdict.get(attribute)
    if(value is None):
        if(exception):
            raise KeyError("Unknown attribute: " + attribute)
    return value

def getStateMode(mode,architecture,attribute,exception=True):
    """
    This returns the attribute requested for the given mode and architecture.
    """
    if(buildSettings is None or (not isinstance(buildSettings,BuildSettings)) or attribute is None):
        raise Exception("Invalid arguments to getState %s %s",str(buildSettings),attribute)
    adict = state.get(architecture)
    if(adict == None):
        raise KeyError("Unknown architecture: " + architecture)
    mdict = adict.get(mode)
    if(mdict == None):
        raise KeyError("Unknown mode: " + mode)
    value = mdict.get(attribute)
    if(value is None):
        if(exception):
            raise KeyError("Unknown attribute: " + attribute)
    return value


def setArchitectureState(buildSettings,attribute,value):
    """
    This sets the attribute to the value for the given mode and architecture.
    """
    mode = buildSettings.mode()
    architecture = buildSettings.architecture()
    if(mode == None or architecture == None or attribute == None):
        raise Exception("Invalid arguments to getState")
    adict = state.get(architecture)
    if(adict == None):
        raise KeyError("Unknown architecture: " + architecture)
    mdict = adict.get(mode)
    if(mdict == None):
        raise KeyError("Unknown mode: " + mode)
    mdict[attribute] = value

def getLibSpecific(mode,architecture,libraryBaseName,attribute):
    """
    Get the library specific attribute for the given library, mode, and architecture.
    """
    if(libraryBaseName == None or attribute == None or mode is None or architecture is None):
        raise Exception("Invalid arguments to getLibSpecific")
    try:
        libspecific = getStateMode(mode,architecture,'libspecific')[libraryBaseName][attribute]
    except KeyError, e:
        return None
    return libspecific
    
def setLibSpecific(mode,architecture,libraryBaseName,attribute,value):
    """
    This sets the given attribute for the given mode and architecture.
    """
    if(type(architecture)==list):
        for arch in architecture:
            setLibSpecific(mode,arch,libraryBaseName,attribute,value)
        return
    elif(architecture=='all'):
        for arch in state['architectures']:
            setLibSpecific(mode,arch,libraryBaseName,attribute,value)
        return
    elif(mode=='all'):
        for lmode in state[architecture]['modes']:
            setLibSpecific(lmode,architecture,libraryBaseName,attribute,value)
        return
    if(libraryBaseName == None or attribute == None):
        raise Exception("Invalid arguments to getLibSpecific")
    try:
        libspecific = getStateMode(mode,architecture,'libspecific')
    except KeyError:
        libspecific = state[architecture][mode]['libspecific']={}
    try:
        llspec = libspecific[libraryBaseName]
    except:
        llspec = libspecific[libraryBaseName] = { }
    llspec[attribute]=value
    return value

def performLibSpecificTemplate(buildSettings,libraryBaseName,s):
    """
    Perform lib specific template evaluation on s
    """
    prefixpath = buildSettings.getPrefixPath()
    s = s.replace("$SConsInstallPrefixPath",os.path.abspath(prefixpath))
    s = s.replace("$SConsArchitecture",buildSettings.architecture())
    s = s.replace("$SConsMode",buildSettings.mode())
    return s

def setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,stage,attribute,value):
    """
    Sets a library specific export for a stage in the make process.
    """
    if(type(architecture)==list):
        for arch in architecture:
            setLibSpecificStateEnvExport(mode,arch,libraryBaseName,stage,attribute,value)
        return
    elif(architecture=='all'):
        for arch in state['architectures']:
            setLibSpecificStateEnvExport(mode,arch,libraryBaseName,stage,attribute,value)
        return
    elif(mode=='all'):
        for lmode in state[architecture]['modes']:
            setLibSpecificStateEnvExport(lmode,architecture,libraryBaseName,stage,attribute,value)
        return

        
    stageName = 'stage'+str(stage)+'env'
    stageDict = getLibSpecific(mode,architecture,libraryBaseName,stageName)
    if(stageDict is None):
        stageDict = setLibSpecific(mode,architecture,libraryBaseName,stageName,{ })
    stageDict[attribute]=value

def setLibSpecificConfigExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Sets a library specific make export
    """
    setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,0,attribute,value)

def setLibSpecificMakeExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Sets a library specific make export
    """
    setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,1,attribute,value)

def setLibSpecificMakeInstallExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Set a library specific make install export
    """
    setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,2,attribute,value)

def getLibSpecificStageEnvExport(mode,architecture,libraryBaseName,stage,attribute):
    """
    Get a library specific export for a stage in the make process.
    """
    stageName = 'stage'+str(stage)+'env'
    stageDict = getLibSpecific(mode,architecture,libraryBaseName,stageName)
    if(stageDict is None):
        stageDict = getLibSpecific(mode,architecture,libraryBaseName,stageName)
    return performLibSpecificTemplate(mode,architecture,libraryBaseName,stageDict.get(attribute))

def getLibSpecificConfigExport(mode,architecture,libraryBaseName,attribute):
    """
    Get a library specific config export
    """
    return getLibSpecificConfigExport(mode,architecture,libraryBaseName,0,attribute)

def getLibSpecificMakeExport(mode,architecture,libraryBaseName,attribute):
    """
    Get a library specific make export
    """
    return getLibSpecificConfigExport(mode,architecture,libraryBaseName,1,attribute)

def getLibSpecificMakeInstallExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Get a library specific make install export
    """
    return getLibSpecificConfigExport(mode,architecture,libraryBaseName,2,attribute)

def getLibSpecificEnv(buildSettings,libraryBaseName,stage,newenv):
    stageName = 'stage'+str(stage)+'env'
    stageDict = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBaseName,stageName)
    if(stageDict is None):
        return
    for(key,value) in stageDict.items():
        newval = performLibSpecificTemplate(buildSettings,libraryBaseName,value)
        if(key in newenv):
            print "Warning: Env already contains " + key
        newenv[key]=newval

def getLibSpecificConfigEnv(mode,architecture,libraryBaseName,newenv):
    """
    Fill new env with configuration enviroment variables for the given library
    """
    getLibSpecificEnv(mode,architecture,libraryBaseName,0,newenv)

def getLibSpecificMakeEnv(mode,architecture,libraryBaseName,attribute,newenv):
    """
    Fill new env with make enviroment variables for the given library
    """
    getLibSpecificEnv(mode,architecture,libraryBaseName,1,newenv)

def getLibSpecificMakeInstallEnv(mode,architecture,libraryBaseName,attribute,newenv):
    """
    Fill new env with make install enviroment variables for the given library
    """
    getLibSpecificEnv(mode,architecture,libraryBaseName,2,newenv)

def setLibSpecificStageCommand(mode,architecture,libraryBaseName,stage,command):
    """
    Sets the command to run at the specific stage of library compilation.
    """
    setLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage)+'cmd',command)

def getLibSpecificStageCommand(buildSettings,libraryBaseName,stage):
    """
    Get the command that is run at a specific stage of library compilation.
    This will raise a key error if the stage does not exist.
    If the command has not been set, it will return the defaults of configure/make/make (install)
    """
    cmd =  getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBaseName,'stage'+str(stage)+'cmd')
    if(cmd is None):
        if(stage==0):
            return 'configure'
        elif(stage==1):
            return 'make'
        elif(stage==2):
            return 'make'
        else:
            raise KeyError
    return cmd

def setLibSpecificStageCommandArguments(mode,architecture,libraryBaseName,stage,args):
    """
    Set the arguments for the command that is run at a specific stage of library compilation.
    """
    attribute = 'stage'+str(stage)+'args'
    setLibSpecific(mode,architecture,libraryBaseName,attribute,args)

def getLibSpecificStageCommandArguments(buildSettings,libraryBaseName,stage):
    """
    Return the arguments for the command that is run at a specific stage of library compilation.
    This will raise a key error if the stage does not exist.
    If the args have not been set, will return defaults of [],[],[install]
    """
    attribute = 'stage'+str(stage)+'args'
    oldArgs = getLibSpecific(buildSettings.mode(),buildSettings.architecture(),libraryBaseName,attribute)
    args=[]
    if(oldArgs is not None):
        for i in range(0,len(oldArgs)):
            args.append(performLibSpecificTemplate(buildSettings,libraryBaseName,oldArgs[i]))
    else:
        args = []
        if(stage==2):
            args = ['install']
    return args

def getLibSpecificNumStages(mode,architecture,libraryBaseName):
    """
    Return the number of stages for building a given library.  This defaults to 3.
    """
    numStages = getLibSpecific(mode,architecture,libraryBaseName,'numStages')
    if(numStages is None):
        return 3
    else:
        return int(numStages)

def setLibSpecificNumStages(mode,architecture,libraryBaseName,stages):
    """
    Set the number of library specific stages.  
    """
    setLibSpecific(mode,architecture,libraryBaseName,'numStages',stages)

def Glob( pattern = '*.*', dir = '.' ):
    import os, fnmatch
    files = []
    for file in os.listdir( Dir(dir).srcnode().abspath ):
        if fnmatch.fnmatch(file, pattern) :
            files.append( file )
    return files

def  determineNumberOfCPUs():
    """
    Number of virtual or physical CPUs on this system, i.e.
    user/real as output by time(1) when called with an optimally scaling
    userspace-only program
    See: http://stackoverflow.com/questions/1006289/how-to-find-out-the-number-of-cpus-in-python
    """
    import os,re,subprocess
    # Python 2.6+
    try:
        import multiprocessing
        return multiprocessing.cpu_count()
    except (ImportError,NotImplementedError):
        pass

    # POSIX
    try:
        res = int(os.sysconf('SC_NPROCESSORS_ONLN'))

        if res > 0:
            return res
    except (AttributeError,ValueError):
        pass

    # Windows
    try:
        res = int(os.environ['NUMBER_OF_PROCESSORS'])

        if res > 0:
            return res
    except (KeyError, ValueError):
        pass

    # BSD
    try:
        sysctl = subprocess.Popen(['sysctl', '-n', 'hw.ncpu'],
                                      stdout=subprocess.PIPE)
        scStdout = sysctl.communicate()[0]
        res = int(scStdout)

        if res > 0:
            return res
    except (OSError, ValueError):
        pass

    # Linux
    try:
        res = open('/proc/cpuinfo').read().count('processor\t:')

        if res > 0:
            return res
    except IOError:
        pass

    # Solaris
    try:
        pseudoDevices = os.listdir('/devices/pseudo/')
        expr = re.compile('^cpuid@[0-9]+$')

        res = 0
        for pd in pseudoDevices:
            if expr.match(pd) != None:
                res += 1

        if res > 0:
            return res
    except OSError:
        pass

    # Other UNIXes (heuristic)
    try:
        try:
            dmesg = open('/var/run/dmesg.boot').read()
        except IOError:
            dmesgProcess = subprocess.Popen(['dmesg'], stdout=subprocess.PIPE)
            dmesg = dmesgProcess.communicate()[0]

        res = 0
        while '\ncpu' + str(res) + ':' in dmesg:
            res += 1

        if res > 0:
            return res
    except OSError:
        pass

    return 1

#Number of cores.  Use this for autoscaling.
numCore = determineNumberOfCPUs()
#Number of subtasks
numSubTasks = numCore

def numberSubTasks():
    """
    Return the number of parallel make subtasks allowed.
    """
    return numSubTasks

#Number of parallel jobs
numJobs = determineNumberOfCPUs()

def numberJobs():
    """
    Return the number of jobs the build is using
    """
    return numJobs

#Original number of jobs (-j parameter)
originalNumJobs = GetOption('num_jobs')
#Set appropriate auto parallel settings.
if(GetOption('disableparallel') is not None):
    print 'Parallel build disabled'
    numJobs = 1
    numSubTasks = 1
elif originalNumJobs==1:
    SetOption('num_jobs', numCore)
    print 'Autodetected ' + str(numCore) + ' CPUs.'
else:
    numJobs = originalNumJobs
#If the user requested to specify number of subtasks, do it.
if(GetOption('jj')):
    numSubTasks=GetOption('jj')
    print "Setting subtasks: " + str(numSubTasks)
if(GetOption('enabledownload') is not None):
    state['enabledownload'] = True

#Set the state based on if clean was requested.
if(GetOption('clean')!=None or GetOption('deepcleanlib')!=None or GetOption('cleanlib')!=None):
    state['build']=False
    state['clean']=True
#Detect current architecture to build under.
architecture = detectArchitecture()
#Requested build modes.
modes = GetOption('modes')
#List of modes requested to build.
splitModes = modes.split(',')
#Requested build distributions.
distributions=GetOption('distribution')
#List of distributions requested to build.
distributions = distributions.split(',')
#List of build settings to build.
buildSettingsList = []
for mode in splitModes:
    for distribution in distributions:
        buildSettings = BuildSettings(architecture,mode,distribution)
        buildSettings.setState('prefixpath','local/'+architecture+'/'+distribution+'/'+mode+'/')
        buildSettings.setState('buildpath','BUILD/'+architecture+'/'+distribution+'/'+mode+'/')
        try:
            setArchitectureState(buildSettings,'build',True)
            #handle clean lib
            if(GetOption('cleanlib')!=None):
                if(GetOption('cleanlib')=='all'):
                    buildSettings.setState('cleanlib',True)
                else:
                    splitCleanLib = GetOption('clean').split(',')
                    for s in splitCleanLib:
                        buildSettings.setLibSpecific(s,'clean',True)
            #handle deep clean
            if(GetOption('deepcleanlib')!=None):
                if(GetOption('deepcleanlib')=='all'):
                    buildSettings.setState('deepclean',True)
                else:
                    splitDeepCleanLib = GetOption('deepcleanlib').split(',')
                    for s in splitDeepCleanLib:
                        buildSettings.setLibSpecific(s,'deepclean',True)
            #handle configlib
            if(GetOption('configlib')!=None):
                if(GetOption('configlib')=='all'):
                    setArchitectureState(buildSettings,'configlib',True)
                else:
                    splitConfigLib = GetOption('configlib').split(',')
                    for s in splitConfigLib:
                        setLibSpecific(mode,architecture,s,'config',True)            
            #handle makelib
            if(GetOption('makelib')!=None):
                if(GetOption('makelib')=='all'):
                    setArchitectureState(buildSettings,'makelib',True)
                else:
                    splitMakeLib = GetOption('makelib').split(',')
                    for s in splitMakeLib:
                        setLibSpecific(mode,architecture,s,'make',True)            
        except KeyError:
            raise Exception('Unknown mode: "' + mode + '" on "' + architecture + '" with distribution "' + distribution + '"')
        buildSettingsList.append(buildSettings)

exportDict = {'state':state,
        'getLibSpecific':getLibSpecific,
        'setLibSpecific':setLibSpecific,
        'getState':getState,
        'setArchitectureState':setArchitectureState,
        'numberJobs':numberJobs,
        'numberSubTasks':numberSubTasks,
        'setLibSpecificStateEnvExport':setLibSpecificStateEnvExport,
        'setLibSpecificConfigExport':setLibSpecificConfigExport,
        'setLibSpecificMakeExport':setLibSpecificMakeExport,
        'setLibSpecificMakeInstallExport':setLibSpecificMakeInstallExport,
        'setLibSpecificNumStages':setLibSpecificNumStages,
        'setLibSpecificStageCommandArguments':setLibSpecificStageCommandArguments,
        'setLibSpecificStageCommand':setLibSpecificStageCommand,
        'getLibSpecificStageEnvExport':getLibSpecificStageEnvExport,
        'getLibSpecificConfigEnv':getLibSpecificConfigEnv,
        'getLibSpecificMakeEnv':getLibSpecificMakeEnv,
        'getLibSpecificMakeInstallEnv':getLibSpecificMakeInstallEnv,
        'getLibSpecificNumStages':getLibSpecificNumStages,
        'getLibSpecificStageCommandArguments':getLibSpecificStageCommandArguments,
        'getLibSpecificStageCommand':getLibSpecificStageCommand,
        'getLibSpecificEnv':getLibSpecificEnv,
        'performLibSpecificTemplate':performLibSpecificTemplate,
        'buildSettingsList':buildSettingsList,
        'Glob':Glob,
        }
exportDict['exportDict']=exportDict

for buildSettings in buildSettingsList:
    ed = dict(exportDict)
    ed['buildSettings'] = buildSettings
    ed['exportDict']=ed
    SConscript('Macaulay2/SConscript', exports=ed, variant_dir=buildSettings.getBuildPath()+'Macaulay2/', duplicate=0)
SConscript('libraries/SConscript', exports=exportDict)

