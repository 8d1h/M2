import os.path
defaultModes = 'debug'
AddOption('--deepcleanlib',dest='deepcleanlib',nargs=1,action='store',type='string',help='Remove all libraries or the specified library only')
AddOption('--cleanlib',dest='cleanlib',nargs=1,action='store',type='string',help='Clean all libraries or the specified library only')
AddOption('--configlib',dest='configlib',nargs=1,action='store',type='string',help='Reconfigure and remake the specified library only')
AddOption('--makelib',dest='makelib',nargs=1,action='store',type='string',help='Remake the specified library only')
AddOption('--modes',dest='modes',nargs=1,action='store',type='string',default='release,debug',help='One or more modes to build separated by commas.  Defaults to ' + defaultModes)
AddOption('--jj',dest='jj',nargs=1,action='store',type='int',help='Number of parallel sub-tasks to run for each build task')
AddOption('--disable-parallel',dest='disableparallel',nargs=0,action='store',help='Disable parallel build')
AddOption('--disable-download',dest='disabledownload',nargs=0,action='store',help='Disable downloading packages')
state = {
    'linux-x86_64':
        {
        'debug':{
            'prefixpath':'local/debug/',
            'includepath':'local/debug/include/',
            'libpath':'local/debug/lib',
            'buildpath':'BUILD/debug/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{ },
            'eflags':'-O0 -g',
            'M2flags':'-O0 -g',
            },
        'release':{
            'prefixpath':'local/release/',
            'includepath':'local/release/include/',
            'libpath':'local/release/lib/',
            'buildpath':'BUILD/release/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{},
            'eflags':'-O2 -g',
            'M2flags':'-O2 -g',
            },
        'modes':set(['debug','release']),
        },
    'linux-x86':
        {
        'debug':{
            'prefixpath':'local/debug/',
            'includepath':'local/debug/include/',
            'libpath':'local/debug/lib/',
            'buildpath':'BUILD/debug/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{ },
            'eflags':'-O0 -g',
            'M2flags':'-O0 -g',
            },
        'release':{
            'prefixpath':'local/release/',
            'includepath':'local/release/include/',
            'libpath':'local/release/lib/',
            'buildpath':'BUILD/release/',
            'tarpath':'BUILD/tarfiles/',
            'build':False,
            'libspecific':{},
            'eflags':'-O2 -g',
            'M2flags':'-O2 -g',
            },
        'modes':set(['debug','release']),
        },
    'architectures':['linux-x86_64','linux-x86'],
    'build':True,
    'clean':False,
    'enabledownload':True
}
def detectArchitecture():
    import platform
    if platform.system()=='Linux':
        if platform.architecture()[0]=='64bit':
            return 'linux-x86_64'
        elif platform.architecture()[0]=='32bit':
            return 'linux-x86'
        else:
            raise NotImplementedError("Unknown linux architecture %s" % architecture)
    elif platform.system()=='Darwin':
        if platform.architecture()[0]=='64bit':
            return 'Darwin-x86_64'
        elif platform.architecture()[0]=='32bit':
            return 'Darwin-x86'
        else:
            raise NotImplementedError("Unknown Darwin architecture %s" % architecture)
    elif platform.system()=='nt':
        if platform.architecture()[0]=='64bit':
            return 'nt-x86_64'
        elif platform.architecture()[0]=='32bit':
            return 'nt-x86'
        else:
            raise NotImplementedError("Unknown NT architecture %s" % architecture)
    else:
        raise NotImplementedError("Unknown NT architecture %s" % architecture)

def getState(mode,architecture,attribute,exception=True):
    """
    This returns the attribute requested for the given mode and architecture.
    """
    if(mode == None or architecture == None or attribute == None):
        raise Exception("Invalid arguments to getState %s %s %s",mode,architecture,attribute)
    adict = state.get(architecture)
    if(adict == None):
        raise KeyError("Unknown architecture: " + architecture)
    mdict = adict.get(mode)
    if(mdict == None):
        raise KeyError("Unknown mode: " + mode)
    value = mdict.get(attribute)
    if(value is None):
        if(exception):
            raise KeyError("Unknown attribute: " + attribute)
    return value

def setState(mode,architecture,attribute,value):
    """
    This sets the attribute to the value for the given mode and architecture.
    """
    if(mode == None or architecture == None or attribute == None):
        raise Exception("Invalid arguments to getState")
    adict = state.get(architecture)
    if(adict == None):
        raise KeyError("Unknown architecture: " + architecture)
    mdict = adict.get(mode)
    if(mdict == None):
        raise KeyError("Unknown mode: " + mode)
    mdict[attribute] = value

def getLibSpecific(mode,architecture,libraryBaseName,attribute):
    """
    Get the library specific attribute for the given library, mode, and architecture.
    """
    if(libraryBaseName == None or attribute == None or mode is None or architecture is None):
        raise Exception("Invalid arguments to getLibSpecific")

    try:
        libspecific = getState(mode,architecture,'libspecific')[libraryBaseName][attribute]
    except KeyError, e:
        return None
    return libspecific
    
def setLibSpecific(mode,architecture,libraryBaseName,attribute,value):
    """
    This sets the given attribute for the given mode and architecture.
    """
    if(type(architecture)==list):
        for arch in architecture:
            setLibSpecific(mode,arch,libraryBaseName,attribute,value)
        return
    elif(architecture=='all'):
        for arch in state['architectures']:
            setLibSpecific(mode,arch,libraryBaseName,attribute,value)
        return
    elif(mode=='all'):
        for lmode in state[architecture]['modes']:
            setLibSpecific(lmode,architecture,libraryBaseName,attribute,value)
        return
    if(libraryBaseName == None or attribute == None):
        raise Exception("Invalid arguments to getLibSpecific")
    try:
        libspecific = getState(mode,architecture,'libspecific')
    except KeyError:
        libspecific = state[architecture][mode]['libspecific']={}
    try:
        llspec = libspecific[libraryBaseName]
    except:
        llspec = libspecific[libraryBaseName] = { }
    llspec[attribute]=value
    return value

def performLibSpecificTemplate(mode,architecture,libraryBaseName,s):
    """
    Perform lib specific template evaluation on s
    """
    prefixpath = getState(mode,architecture,'prefixpath')
    s = s.replace("$SConsInstallPrefixPath",os.path.abspath(prefixpath))
    s = s.replace("$SConsArchitecture",architecture)
    s = s.replace("$SConsMode",mode)
    return s

def setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,stage,attribute,value):
    """
    Sets a library specific export for a stage in the make process.
    """
    if(type(architecture)==list):
        for arch in architecture:
            setLibSpecificStateEnvExport(mode,arch,libraryBaseName,stage,attribute,value)
        return
    elif(architecture=='all'):
        for arch in state['architectures']:
            setLibSpecificStateEnvExport(mode,arch,libraryBaseName,stage,attribute,value)
        return
    elif(mode=='all'):
        for lmode in state[architecture]['modes']:
            setLibSpecificStateEnvExport(lmode,architecture,libraryBaseName,stage,attribute,value)
        return

        
    stageName = 'stage'+str(stage)+'env'
    stageDict = getLibSpecific(mode,architecture,libraryBaseName,stageName)
    if(stageDict is None):
        stageDict = setLibSpecific(mode,architecture,libraryBaseName,stageName,{ })
    stageDict[attribute]=value

def setLibSpecificConfigExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Sets a library specific make export
    """
    setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,0,attribute,value)

def setLibSpecificMakeExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Sets a library specific make export
    """
    setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,1,attribute,value)

def setLibSpecificMakeInstallExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Set a library specific make install export
    """
    setLibSpecificStateEnvExport(mode,architecture,libraryBaseName,2,attribute,value)

def getLibSpecificStageEnvExport(mode,architecture,libraryBaseName,stage,attribute):
    """
    Get a library specific export for a stage in the make process.
    """
    stageName = 'stage'+str(stage)+'env'
    stageDict = getLibSpecific(mode,architecture,libraryBaseName,stageName)
    if(stageDict is None):
        stageDict = getLibSpecific(mode,architecture,libraryBaseName,stageName)
    return performLibSpecificTemplate(mode,architecture,libraryBaseName,stageDict.get(attribute))

def getLibSpecificConfigExport(mode,architecture,libraryBaseName,attribute):
    """
    Get a library specific config export
    """
    return getLibSpecificConfigExport(mode,architecture,libraryBaseName,0,attribute)

def getLibSpecificMakeExport(mode,architecture,libraryBaseName,attribute):
    """
    Get a library specific make export
    """
    return getLibSpecificConfigExport(mode,architecture,libraryBaseName,1,attribute)

def getLibSpecificMakeInstallExport(mode,architecture,libraryBaseName,attribute,value):
    """
    Get a library specific make install export
    """
    return getLibSpecificConfigExport(mode,architecture,libraryBaseName,2,attribute)

def getLibSpecificEnv(mode,architecture,libraryBaseName,stage,newenv):
    stageName = 'stage'+str(stage)+'env'
    stageDict = getLibSpecific(mode,architecture,libraryBaseName,stageName)
    if(stageDict is None):
        return
    for(key,value) in stageDict.items():
        newval = performLibSpecificTemplate(mode,architecture,libraryBaseName,value)
        if(key in newenv):
            print "Warning: Env already contains " + key
        newenv[key]=newval

def getLibSpecificConfigEnv(mode,architecture,libraryBaseName,newenv):
    """
    Fill new env with configuration enviroment variables for the given library
    """
    getLibSpecificEnv(mode,architecture,libraryBaseName,0,newenv)

def getLibSpecificMakeEnv(mode,architecture,libraryBaseName,attribute,newenv):
    """
    Fill new env with make enviroment variables for the given library
    """
    getLibSpecificEnv(mode,architecture,libraryBaseName,1,newenv)

def getLibSpecificMakeInstallEnv(mode,architecture,libraryBaseName,attribute,newenv):
    """
    Fill new env with make install enviroment variables for the given library
    """
    getLibSpecificEnv(mode,architecture,libraryBaseName,2,newenv)

def setLibSpecificStageCommand(mode,architecture,libraryBaseName,stage,command):
    """
    Sets the command to run at the specific stage of library compilation.
    """
    setLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage)+'cmd',command)

def getLibSpecificStageCommand(mode,architecture,libraryBaseName,stage):
    """
    Get the command that is run at a specific stage of library compilation.
    This will raise a key error if the stage does not exist.
    If the command has not been set, it will return the defaults of configure/make/make (install)
    """
    cmd =  getLibSpecific(mode,architecture,libraryBaseName,'stage'+str(stage)+'cmd')
    if(libraryBaseName=='pari'):
        print mode
        print architecture
        print libraryBaseName
        print cmd
    if(cmd is None):
        if(stage==0):
            return 'configure'
        elif(stage==1):
            return 'make'
        elif(stage==2):
            return 'make'
        else:
            raise KeyError
    return cmd

def setLibSpecificStageCommandArguments(mode,architecture,libraryBaseName,stage,args):
    """
    Set the arguments for the command that is run at a specific stage of library compilation.
    """
    attribute = 'stage'+str(stage)+'args'
    setLibSpecific(mode,architecture,libraryBaseName,attribute,args)

def getLibSpecificStageCommandArguments(mode,architecture,libraryBaseName,stage):
    """
    Return the arguments for the command that is run at a specific stage of library compilation.
    This will raise a key error if the stage does not exist.
    If the args have not been set, will return defaults of [],[],[install]
    """
    attribute = 'stage'+str(stage)+'args'
    oldArgs = getLibSpecific(mode,architecture,libraryBaseName,attribute)
    args=[]
    if(oldArgs is not None):
        for i in range(0,len(oldArgs)):
            args.append(performLibSpecificTemplate(mode,architecture,libraryBaseName,oldArgs[i]))
    else:
        args = []
        if(stage==2):
            args = ['install']
    return args

def getLibSpecificNumStages(mode,architecture,libraryBaseName):
    """
    Return the number of stages for building a given library.  This defaults to 3.
    """
    numStages = getLibSpecific(mode,architecture,libraryBaseName,'numStages')
    if(numStages is None):
        return 3
    else:
        return int(numStages)

def setLibSpecificNumStages(mode,architecture,libraryBaseName,stages):
    """
    Set the number of library specific stages.  
    """
    setLibSpecific(mode,architecture,libraryBaseName,'numStages',stages)

def Glob( pattern = '*.*', dir = '.' ):
    import os, fnmatch
    files = []
    for file in os.listdir( Dir(dir).srcnode().abspath ):
        if fnmatch.fnmatch(file, pattern) :
            files.append( file )
    return files

def  determineNumberOfCPUs():
    """
    Number of virtual or physical CPUs on this system, i.e.
    user/real as output by time(1) when called with an optimally scaling
    userspace-only program
    See: http://stackoverflow.com/questions/1006289/how-to-find-out-the-number-of-cpus-in-python
    """
    import os,re,subprocess
    # Python 2.6+
    try:
        import multiprocessing
        return multiprocessing.cpu_count()
    except (ImportError,NotImplementedError):
        pass

    # POSIX
    try:
        res = int(os.sysconf('SC_NPROCESSORS_ONLN'))

        if res > 0:
            return res
    except (AttributeError,ValueError):
        pass

    # Windows
    try:
        res = int(os.environ['NUMBER_OF_PROCESSORS'])

        if res > 0:
            return res
    except (KeyError, ValueError):
        pass

    # BSD
    try:
        sysctl = subprocess.Popen(['sysctl', '-n', 'hw.ncpu'],
                                      stdout=subprocess.PIPE)
        scStdout = sysctl.communicate()[0]
        res = int(scStdout)

        if res > 0:
            return res
    except (OSError, ValueError):
        pass

    # Linux
    try:
        res = open('/proc/cpuinfo').read().count('processor\t:')

        if res > 0:
            return res
    except IOError:
        pass

    # Solaris
    try:
        pseudoDevices = os.listdir('/devices/pseudo/')
        expr = re.compile('^cpuid@[0-9]+$')

        res = 0
        for pd in pseudoDevices:
            if expr.match(pd) != None:
                res += 1

        if res > 0:
            return res
    except OSError:
        pass

    # Other UNIXes (heuristic)
    try:
        try:
            dmesg = open('/var/run/dmesg.boot').read()
        except IOError:
            dmesgProcess = subprocess.Popen(['dmesg'], stdout=subprocess.PIPE)
            dmesg = dmesgProcess.communicate()[0]

        res = 0
        while '\ncpu' + str(res) + ':' in dmesg:
            res += 1

        if res > 0:
            return res
    except OSError:
        pass

    return 1

#Number of cores.  Use this for autoscaling.
numCore = determineNumberOfCPUs()
#Number of subtasks
numSubTasks = numCore

def numberSubTasks():
    """
    Return the number of parallel make subtasks allowed.
    """
    return numSubTasks

#Number of parallel jobs
numJobs = determineNumberOfCPUs()

def numberJobs():
    """
    Return the number of jobs the build is using
    """
    return numJobs

#Original number of jobs (-j parameter)
originalNumJobs = GetOption('num_jobs')
#Set appropriate auto parallel settings.
if(GetOption('disableparallel') is not None):
    print 'Parallel build disabled'
    numJobs = 1
    numSubTasks = 1
elif originalNumJobs==1:
    SetOption('num_jobs', numCore)
    print 'Autodetected ' + str(numCore) + ' CPUs.'
else:
    numJobs = originalNumJobs
#If the user requested to specify number of subtasks, do it.
if(GetOption('jj')):
    numSubTasks=GetOption('jj')
    print "Setting subtasks: " + str(numSubTasks)
if(GetOption('disabledownload') is not None):
    print 'Downloading libraries disabled'
    state['enabledownload'] = False

#Set the state based on if clean was requested.
if(GetOption('clean')!=None or GetOption('deepcleanlib')!=None or GetOption('cleanlib')!=None):
    state['build']=False
    state['clean']=True
#Detect current architecture to build under.
architecture = detectArchitecture()
#Requested build modes.
modes = GetOption('modes')
#List of modes requested to build.
splitModes = modes.split(',')
for mode in splitModes:
    try:
        setState(mode,architecture,'build',True)
        #handle clean lib
        if(GetOption('cleanlib')!=None):
            if(GetOption('cleanlib')=='all'):
                setState(mode,architecture,'cleanlib',True)
            else:
                splitCleanLib = GetOption('cleanlib').split(',')
                for s in splitCleanLib:
                    setLibSpecific(mode,architecture,s,'clean',True)
        #handle deep clean
        if(GetOption('deepcleanlib')!=None):
            if(GetOption('deepcleanlib')=='all'):
                setState(mode,architecture,'deepcleanlib',True)
            else:
                splitDeepCleanLib = GetOption('deepcleanlib').split(',')
                for s in splitDeepCleanLib:
                    setLibSpecific(mode,architecture,s,'deepclean',True)
        #handle configlib
        if(GetOption('configlib')!=None):
            if(GetOption('configlib')=='all'):
                setState(mode,architecture,'configlib',True)
            else:
                splitConfigLib = GetOption('configlib').split(',')
                for s in splitConfigLib:
                    setLibSpecific(mode,architecture,s,'config',True)            
        #handle makelib
        if(GetOption('makelib')!=None):
            if(GetOption('makelib')=='all'):
                setState(mode,architecture,'makelib',True)
            else:
                splitMakeLib = GetOption('makelib').split(',')
                for s in splitMakeLib:
                    setLibSpecific(mode,architecture,s,'make',True)            
    except KeyError:
        raise Exception('Unknown mode: "' + mode + '"')

exportDict = {'state':state,
        'getLibSpecific':getLibSpecific,
        'setLibSpecific':setLibSpecific,
        'getState':getState,
        'setState':setState,
        'architecture':architecture,
        'numberJobs':numberJobs,
        'numberSubTasks':numberSubTasks,
        'setLibSpecificStateEnvExport':setLibSpecificStateEnvExport,
        'setLibSpecificConfigExport':setLibSpecificConfigExport,
        'setLibSpecificMakeExport':setLibSpecificMakeExport,
        'setLibSpecificMakeInstallExport':setLibSpecificMakeInstallExport,
        'setLibSpecificNumStages':setLibSpecificNumStages,
        'setLibSpecificStageCommandArguments':setLibSpecificStageCommandArguments,
        'setLibSpecificStageCommand':setLibSpecificStageCommand,
        'getLibSpecificStageEnvExport':getLibSpecificStageEnvExport,
        'getLibSpecificConfigEnv':getLibSpecificConfigEnv,
        'getLibSpecificMakeEnv':getLibSpecificMakeEnv,
        'getLibSpecificMakeInstallEnv':getLibSpecificMakeInstallEnv,
        'getLibSpecificNumStages':getLibSpecificNumStages,
        'getLibSpecificStageCommandArguments':getLibSpecificStageCommandArguments,
        'getLibSpecificStageCommand':getLibSpecificStageCommand,
        'getLibSpecificEnv':getLibSpecificEnv,
        'performLibSpecificTemplate':performLibSpecificTemplate,
        'Glob':Glob,
        }
exportDict['exportDict']=exportDict

for mode in state[architecture]['modes']:
    ed = dict(exportDict)
    ed['mode']=mode
    ed['exportDict']=ed
    SConscript('Macaulay2/SConscript', exports=ed, variant_dir=getState(mode,architecture,'buildpath')+'Macaulay2/', duplicate=0)
SConscript('libraries/SConscript', exports=exportDict)

