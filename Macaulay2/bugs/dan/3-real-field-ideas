Date: Fri, 30 Jun 2006 10:56:07 -0500 (CDT)
From: Dan Grayson <dan@math.uiuc.edu>
To: Michael Stillman <mike@math.cornell.edu>
CC: dan@math.uiuc.edu
In-reply-to: <EB1EB6D1-5678-427B-8E7B-92E65CD14B0E@math.cornell.edu> (message
	from Michael Stillman on Fri, 30 Jun 2006 11:30:21 -0400)
Subject: Re: promote
Reply-to: dan@math.uiuc.edu


> From: Michael Stillman <mike@math.cornell.edu>
> Subject: Re: promote
> Date: Fri, 30 Jun 2006 11:30:21 -0400
> To: dan@math.uiuc.edu
> 
> The trouble with having a fixed precision for RRR or CCC is that  
> there are algorithms
> which progress: increase the precision as the algorithm continues  
> (e.g. Newton iteration).
> By fixing the precision, we are removing the possibility of these.

Not *removing* the possibility, just changine the way you do it.  There will be
lift and promote between the various RRR rings, and lifting will be the same as
promotion.

Example:

	prec = 5;
	x = 1.0;
	while prec < 1000
	do (
	   R = realField(Precision => prec);
	   x = promote(x, R);
	   x = .... code for improving the approximation ...;
	   prec = 2*prec;
	   )
	return x

I suppose realField could return RR if prec < 16.

None of the code above involves the engine.

A real field will be a light weight object at top level, since it will store
just a precision.  The methods can all be inherited.  The real fields,
including RR, can all have a common parent class called RealNumber.  All the
methods can be stored there.  When creating a new real field, we won't install
any new methods, so it won't take any time.

The engine will have to take care of this, too.  Mutable matrices over RRR have
to refer somehow to the precision, etc.

You might think that adds complication, but it will actually simplify a lot of
things where it's not important to set or change the precision, such as in
matrix multiplication.

> But I also don't like the global precision...

A global precision variable will probably not work.

