Check that this algorithm is right for modules over rings with strange negative
multidegrees and unusual heft vectors.

degree Module := (
     () -> (
     	  -- constants:
	  ZZ1 := degreesRing 1;
	  T := ZZ1_0;
	  h := 1 - T;
	  local ev;
	  M -> (
	       hs := hilbertSeries M;
	       hn := numerator hs;
	       hd := value denominator hs;
	       if hn == 0 then return 0;
	       n := degreeLength M;
	       if n === 0 then return lift(hn,ZZ);		    -- assert( hd == 1 );
	       to1 := map(ZZ1,ring hn,toList(n:T));
	       hn = to1 hn;
	       if hn == 0 then return 0;
	       hd = to1 hd;
	       while hn % h == 0 do hn = hn // h;
	       while hd % h == 0 do hd = hd // h;
	       if ev === null then ev = map(ZZ,ZZ1,{1}); -- ring maps are defined only later
	       x := ev hn/ev hd;
	       if liftable(x,ZZ) then x = lift(x,ZZ);
	       x)))()
