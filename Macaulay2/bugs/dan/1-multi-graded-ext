Date: Fri, 23 Mar 2007 22:36:42 -0500 (CDT)
From: "Daniel R. Grayson" <dan@math.uiuc.edu>
To: "Paul S. Aspinwall" <psa@cgtp.duke.edu>
CC: dan@math.uiuc.edu
In-reply-to: <17924.8565.554784.893338@gauss.cgtp.duke.edu>
	(psa@cgtp.duke.edu)
Subject: Re: Degree of transpose
Reply-to: dan@math.uiuc.edu


That would be great, but I'd like to include something slightly better, as I
mentioned.  How about saying that a future version of Macaulay 2 will include
code to handle the multi-graded Ext?

> From: "Paul S. Aspinwall" <psa@cgtp.duke.edu>
> Date: Fri, 23 Mar 2007 14:50:29 -0400
> To: dan@math.uiuc.edu
> Subject: Re: Degree of transpose
> 
> Dear Dan,
> 
> I am currently writing a paper that uses the multi-graded version of
> Ext. Would it be true/acceptable if I state in my paper that a future
> version of Macaulay 2 will be expected to have the code 
> below incorporated into it?
> 
> Daniel R. Grayson writes:
>  > 
>  > Looks good!
>  > 
>  > I think I'll do it slightly differently, to allow for the possibility that
>  > (degreeLength A):1 is not a valid heft vector for A, using (options A).Heft
>  > instead.
>  > 
>  > > From: "Paul S. Aspinwall" <psa@cgtp.duke.edu>
>  > > Date: Fri, 16 Mar 2007 14:00:12 -0400
>  > > To: dan@math.uiuc.edu
>  > > Subject: Re: Degree of transpose
>  > > 
>  > > Dear Dan,
>  > > 
>  > > I fixed it myself. The code changes I did were:
>  > > 
>  > >          -- compute the fudge factor for the adjustment of bidegrees
>  > >          fudge := if #f > 0 then 1 + max(sum \ degree \ f) // 2 else 0;
>  > >          S := K(monoid [p_1 .. p_c, toSequence gens monoid A,
>  > >            Degrees => {
>  > >              apply(0 .. c-1, i -> prepend(-2, - degree f_i)),
>  > >              apply(0 .. n-1, j -> prepend(0, degree A_j))
>  > >              },
>  > >            Heft => prepend(-fudge,toList((degreeLength A):1))
>  > >            ]);
>  > > 
>  > > ...
>  > > 
>  > >          Cstar := S^(apply(spots C,
>  > >              i -> toSequence apply(degrees C_i, d -> prepend(i, d))));
>  > >          -- assemble the matrix from its blocks.
>  > >          -- We omit the sign (-1)^(n+1) which would ordinarily be used,
>  > >          -- which does not affect the homology.
>  > >          toS := map(S,A,apply(toList(c .. c+n-1), i -> S_i),
>  > >            DegreeMap => prepend_0);
>  > >          Delta := map(Cstar, Cstar, 
>  > >            transpose sum(keys blks, m -> S_m * toS sum blks#m),
>  > >            Degree => prepend(-1,toList((degreeLength A):0)));
>  > > 
>  > > That last line (and the one with Heft above) looks a little ugly to me
>  > > - perhaps you could do it more elegantly!
>  > > 
>  > > Daniel R. Grayson writes:
>  > >  > 
>  > >  > Now the only requirement is that we be able to find a suitable "heft vector", a
>  > >  > list of integers whose dot product with the multidegrees of the variables will
>  > >  > be positive.  (Mike, correct me if I'm wrong.)  See the description of the Heft
>  > >  > option to the monoid command.  So we should be able to rewrite the code for
>  > >  > Ext(Module,Module).  We can automatically find a heft vector for the new ring
>  > >  > by using the heft vector for the old ring, obtainable as (options A).Heft.
>  > >  > These would be the lines in ext.m2 to change:
>  > >  > 
>  > >  >     -- compute the fudge factor for the adjustment of bidegrees
>  > >  >     fudge := if #f > 0 then 1 + max(first \ degree \ f) // 2 else 0;
>  > >  >     S := K(monoid [X_1 .. X_c, toSequence A.generatorSymbols,
>  > >  >       Degrees => {
>  > >  >         apply(0 .. c-1, i -> {-2, - first degree f_i}),
>  > >  > 	apply(0 .. n-1, j -> { 0,   first degree A_j})
>  > >  >         },
>  > >  >       Heft => {-fudge, 1}
>  > >  >       ]);
>  > >  > 
>  > > 
> 

