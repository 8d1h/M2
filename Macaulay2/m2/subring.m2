-- Copyright 1996 Michael E. Stillman

SubringComputation = new SelfInitializingType of BasicList
PushforwardComputation = new SelfInitializingType of BasicList

-- valid values are (a) {J,cleanup code}   -- J is the aux matrix and the code to derive
-- 						the answer is the 2nd element.
--               or (b) {answer}           -- answer is a matrix

--subringOptions := mergeOptions(options gb, Strategy => , UseHilbertFunction => true

pushForward1 = method(
     Options => {
	  Strategy => NonLinear,            -- use the best choice
	  UseHilbertFunction => true,  -- if possible
	  MonomialOrder => EliminationOrder,
				       -- EliminationOrder, ProductOrder, LexOrder
	  StopWithMinimalGenerators => false,            -- determine the minimal generators of the subring
	  BasisElementLimit => infinity,  -- number of generators of GB in the subring

	  StopBeforeComputation => false,
	  DegreeLimit => {},
	  PairLimit => infinity
	  }
     )

pushtest := (f,M,options) -> (
    comp := PushforwardComputation{M,NonLinear};
    if not f#?comp then (
	-- create the computation
	S := source f;
	n1 := numgens target f;
        order := if options.MonomialOrder === EliminationOrder then 
                     Eliminate n1
                 else if options.MonomialOrder === ProductOrder then 
		     ProductOrder{n1, numgens S}
		 else
		     Lex;
	JJ := graphIdeal(f,MonomialOrder => order, VariableBaseName => local X);
	m := presentation M;
	-- now map M to the new ring.
	xvars := map(ring JJ, ring M, submatrix(vars ring JJ, toList(0..n1-1)));
	m1 := xvars m;
	m1 = presentation ((cokernel m1) ** (cokernel JJ));
	mapback := map(S, ring JJ, map(S^1, S^n1, 0) | vars S);

	if options.UseHilbertFunction 
           and isHomogeneous m1 and isHomogeneous f and isHomogeneous m then (
	    hf := poincare cokernel m;
	    T := (ring hf)_0;
	    hf = hf * product(numgens source JJ, i -> (d := (degrees source JJ)#i#0; 1 - T^d));
	    (cokernel m1).poincare = hf;
	    );

	cleanupcode := g -> mapback selectInSubring(1,generators g);

	f#comp = {m1, cleanupcode};
	);

    if #( f#comp ) === 1 then
	f#comp#0
    else (
	gboptions := new OptionTable from {
			StopBeforeComputation => options.StopBeforeComputation,
			DegreeLimit => options.DegreeLimit,
			PairLimit => options.PairLimit};
	m1 = f#comp#0;
	g := gb(m1,gboptions);
	result := f#comp#1 g;
	--if isdone g then f#comp = {result};  -- MES: There is NO way to check this yet!!

	-- MES: check if the monomial order restricts to S.  If so, then do
        -- forceGB result;
	result
	)
    )

pushlinear := (f,M,options) -> (
    -- assumptions here:
    -- (a) f is homogeneous linear, and the linear forms are independent
    -- 
    -- First bring M over to a ring with an elimination order, which eliminates
    -- the variables 'not in' f.
    m := presentation M;    
    R := target f;
    S := source f;
    Rbase := ultimate(ambient, R);
    fmat := substitute(f.matrix,Rbase);
    n := numgens source f.matrix;
    n1 := numgens R - n;
    R1 := (ring Rbase)[Variables => numgens R, MonomialOrder => Eliminate n1];
    fg := newCoordinateSystem(R1, fmat);
    Fto := fg#0;  -- we don't need to go back, so we ignore fg#1
    m1 := Fto substitute(m,Rbase);
    m1 = presentation (cokernel m1 ** cokernel Fto presentation R);
    if isHomogeneous f and isHomogeneous m then (
        hf := poincare cokernel m;
        T := (ring hf)_0;
        (cokernel m1).poincare = hf;
        );
    g := selectInSubring(1, generators gb(m1,options));
    -- now map the answer back to S = source f.
    mapback := map(S, R1, map(S^1, S^n1, 0) | submatrix(vars S, {0..n-1}));
    mapback g
    )

document { quote NonLinear,
     TT "Strategy => NonLinear", " -- an option value for the ", TO "Strategy", "
     option to ", TO "pushForward1", "."
     }

pushForward1(RingMap, Module) := (f,M,options) -> (
    if options.Strategy === Linear then
        pushlinear(f,M,options)
    else if options.Strategy === NonLinear then
        pushtest(f,M,options)
    else error "unrecognized Strategy"
    )

document { quote pushForward1,
    TT "pushForward1(f,M,options)", " -- Given a ring map f : R --> S, and an S-module
    M, yields a presentation matrix of the R-submodule of M generated by the given
    (S-module) generators of M.",
    PARA,
    "Warning: this function will be removed, and its function incorporated into
    that of ", TO "image", " and ", TO "prune", ".",
    PARA,
    "This is a very basic operation, and is used by several other functions.  See,
    for example, ", TO "pushForward", ".  Therefore we intend to eliminate it,
    and merge its function into ", TO "image", " after introducing
    generalized module homomorphisms which map an R-module to an S-module.",
    PARA,
    "As an example, the following fragment computes the ideal of the
    rational normal curve. This could also be done using ", TO "monomialCurve", ".",
    EXAMPLE "R = ZZ/101[a..d]",
    EXAMPLE "S = ZZ/101[s,t]",
    EXAMPLE "f = map(S,R,matrix{{s^4, s^3*t, s*t^3, t^4}})",
    EXAMPLE "pushForward1(f,S^1)",
    PARA,
    "This function accepts the following optional arguments.  For each, the possible
    values are given.  If a default value is not given, that means that the best
    choice depending on the input is given.",
    MENU {
	(TO "Strategy", " -- The computation strategy to use.  If none is given, chooses
                        heuristically the best one.  Possible values are",
		MENU {
			(TO "NonLinear"),
			(TO "Linear")
			}),

	(TO "UseHilbertFunction", " -- true or false.  The default is to use it if possible"),
	HR,
	(TO "MonomialOrder", " -- The monomial order to use for the resulting 
                             Groebner basis computation.  Possible values are",
		MENU {
			(TO "EliminationOrder", " -- the default"),
			(TO "ProductOrder"),
			(TO "Lex")
		    }),
	HR,
	(TO "DegreeLimit", " -- The maximum degree to which to compute, computed in 
			   terms of the degrees of the ring map 'f'.  For example,
			   if f consists of cubics, then to find a quadratic relation,
			   this option should be set to at least 6, e.g. DegreeLimit => 6.
			   The default is 'infinity'"),
	(TO "PairLimit", " -- The number of s pair events to compute.  The default is 
			   'infinity'")
        },

    PARA,
    "For example, ",
    EXAMPLE "pushForward1(f,S^1,MonomialOrder=>ProductOrder)",
    "performs the Groebner computation using a product order rather than the
    default elimination order.",
    PARA,
    "The computation is stashed inside the ring map, until the computation has
    finished completely.  This means that you may interrupt this command, and 
    later restart it. You may alo obtain partial results.",
    EXAMPLE "f = map(S,R,matrix{{s^4, s^3*t, s*t^3, t^4}})",
    EXAMPLE "pushForward1(f,S^1,DegreeLimit=>4)",
    "After interrupting a computation (using control-C), you may view the
    equations so far obtained using",
    EXAMPLE "pushForward1(f,S^1,PairLimit=>0)",
    "Types used:",
    MENU {
	 TO "PushforwardComputation",
	 TO "SubringComputation"
	 }
    }

document { quote PushforwardComputation,
     TT "PushforwardComputation", " -- a type of list used internally by
     ", TO "pushForward1", "."
     }

document { quote SubringComputation,
     TT "SubringComputation", " -- a type of list used internally by
     ", TO "pushForward1", "."
     }

document { quote EliminationOrder,
     TT "EliminationOrder", " -- a value for the ", TO "MonomialOrder", "
     option to ", TO "pushForward1", " which specifies the natural elimination
     order be used."
     }


pushForward = method (Options => options pushForward1)

pushForward(RingMap, Module) := (f,M,options) -> (
    -- given f:R-->S, and M an S-module, finite over R, find R-presentation for M
    S := target f;
    M = cokernel presentation M;
    M1 := M ** (S^1/(image f.matrix));
    if dim M1 > 0 then error "module given is not finite over base";
    M2 := subquotient(matrix (basis M1 ** S), relations M);
    cokernel pushForward1(f,M2,options)
    )

document { quote pushForward,
     TT "pushForward", "(f,M) -- yields an R-presentation of the S-module M, where
     f:R --> S is a ring map, and M is considered as an R-module via f.",
     PARA,
     "If M is not finitely generated over R, then an error is raised.",
     PARA,
     "Currently, R and S must both be polynomial rings over the same base field."
     }

TEST "
    R = ZZ/101[a,b]
    S = ZZ/101[a,b,c]
    M = cokernel matrix{{c^3}}
    f = map(S,R)
    assert( R^3 == pushForward(f,M) )
"

document { quote UseHilbertFunction,
     TT "UseHilbertFunction", " -- an option for ", TO "pushForward1", "."
     }
