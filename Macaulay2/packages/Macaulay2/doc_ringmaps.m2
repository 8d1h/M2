document {
     Key => (symbol **, RingMap, Module),
     Headline => "tensor product of a module via a ring map",
     Usage => "f ** M",
     Inputs => {
	  "f" => { "a ring map from ", TT "R", " to ", TT "S" },
	  "M" => { "an ", TT "R", "-module" }
	  },
     Outputs => {
	  { "the tensor product of ", TT "M", " with ", TT "S", " over ", TT "R" }
	  },
     EXAMPLE {
	  "R = QQ[x,y];",
	  "S = QQ[t];",
	  "f = map(S,R,{t^2,t^3})",
	  "f ** coker vars R",
	  "f ** image vars R"
	  },
     SeeAlso => { (symbol " ", RingMap, Module) }
     }

document {
     Key => (symbol " ", RingMap, Module),
     Headline => "apply a ring map to a submodule of a free module",
     Usage => "f M",
     Inputs => {
	  "f" => { "a ring map from ", TT "R", " to ", TT "S", "." },
	  "M" => { "a free ", TT "R", "-module ", TT "R^n", " or a submodule of one" }
	  },
     Outputs => {
	  { "the submodule of ", TT "S^n", " generated by the image of ", TT "M" }
	  },
     EXAMPLE {
	  "R = QQ[x,y];",
	  "S = QQ[t];",
	  "f = map(S,R,{t^2,t^3})",
	  "f image vars R"
	  },
     SeeAlso => { (symbol " ", RingMap, Module) }
     }

document {
     Key => DegreeMap,
     "A name for an optional argument used with ", TT "map", " when
     creating a ring map.",
     SeeAlso => { [map, DegreeMap] }
     }

document { 
     Key => {substitute,
	  (substitute, Vector, Option),
	  (substitute, Product, Thing),
	  (substitute, Matrix, List),
	  (substitute, Ideal, List),
	  (substitute, Module, Matrix),
	  (substitute, Matrix, Ring),
	  (substitute, Matrix, ZZ),
	  (substitute, Ideal, Ring),
	  (substitute, Module, Option),
	  (substitute, Vector, List),
	  (substitute, RingElement, Matrix),
	  (substitute, Vector, Ring),
	  (substitute, RingElement, Option),
	  (substitute, Matrix, Matrix),
	  (substitute, Ideal, Matrix),
	  (substitute, Module, List),
	  (substitute, Divide, Thing),
	  (substitute, Module, Ring),
	  (substitute, Matrix, Option),
	  (substitute, Sum, Thing),
	  (substitute, Ideal, Option),
	  (substitute, Vector, Matrix),
	  (substitute, RingElement, List),
	  (substitute, Power, Thing),
	  (substitute, RingElement, Ring)},
     Headline => "substituting values for variables",
     Usage => "substitute(f,v)\nsub(f,v)",
     Inputs => {
	  "f" => {ofClass RingElement, ", ",
	         ofClass Matrix,", ",
		 ofClass Ideal,", ",
		 ofClass Module,", ",
		 ofClass Vector,", or ",
		 ofClass Expression, " over a ring ", TT "R"},
	  "v" => {ofClass Ring, ", ",
	       ofClass Matrix, ", ",
	       ofClass Option, ", or a list of options"}
	  },
     Outputs => {
	  {"An object of the same sort as ", TT "f", ", obtained by substituting values for
	  the variables in the ring ", TT "R", " of ", TT "f", " using ", TT "v", "."}
	  },
     "A convenient abbreviation for ", TO "substitute", " is ", TT "sub", ".",
     PARA{},
     "The basic idea is that v determines the values for the variables appearing in f, or in the matrix or
     matrices defining f, and the result is obtained by performing this substition on these elements
     or matrices.  For example,",
     EXAMPLE lines ///
     	  A = QQ[a..d]; B = QQ[x,y];
	  sub(x^4-x^2-y-1, x=>y^2)
	  sub(x^2-y^2, {x=>a+b,y=>c+d})
          ///,
     "The result on this last line is obtained by replacing ", TT "x", " with ", TT "a+b", ", and ", TT "y", " with ", TT "c+d", 
     " giving an element in the ring ", TT "A", ".",
     PARA{},
     "If ", TT "v", " is a ring, then the result is obtained by substituting the variables of
     ", TT "v", " for the variables of R with the same name.  The substitution extends
     to the coefficient ring of ", TT "R", ", and so on.",
     EXAMPLE lines ///
	  use A;
	  C = A/(a^2,b^2,c^2,d^2)
	  substitute((a+b+c+d)^3,C)
	  ///,
     EXAMPLE lines ///
	  D = ZZ/101[gens A]; use A;
	  substitute(ideal(a^2-b-1,1/3*a*b), D)
	  ///,
     PARA{},
     "If ", TT "v", " is a 1 by k matrix over another
     ring ", TT "S", ", then the result is obtained by substituting the entries in ", TT "v", " 
     for the variables in ", TT "R", ".",
     EXAMPLE lines ///
          substitute(a^4+b^3+c^2+d+1, matrix{{d,c,b,a}})
	  S = QQ[r,s,t,u];
	  substitute(a^4+b^3+c^2+d+1, vars S)
     	  ///,
     PARA{},
     "If ", TT "f", " is a submodule of a free module over ", TT "R", ", then substitution amounts to substitution
     in the matrices of generators of the module.  This is
     not the same as tensor product!",
     EXAMPLE lines ///
     	  use A;
	  M = image(vars A ++ vars A)
	  N = substitute(M, {a=>b+c,c=>1})
     	  M' = prune M
	  N' = coker substitute(presentation M', {a=>b+c,c=>1})	  
     	  ///,
     PARA{},
     "Unevaluated expressions (i.e. from ", TO hilbertSeries, ") may also
     have variables substituted in all of the ways mentioned so far.",
     EXAMPLE lines ///
     	  hf = hilbertSeries coker matrix{{a,b^3,d^5}}
	  hf1 = reduceHilbert hf
	  use ring numerator hf;
	  sub(hf1, T => -1)
     	  ///,
     "Of course, we can change the ring too:",
     EXAMPLE lines ///
          sub(hf, T => a)
	  value oo
	  oo == value sub(hf1, T=>a)
     	  ///,
     Caveat => "The specified substitution is not checked to see whether
     the corresponding ring homomorphism is well-defined; this may produce
     surprising results, especially if rational coefficients are converted
     to integer coefficients.",
     SeeAlso => {"substitution and maps between rings", hilbertSeries, value, Expression}
     }

document {
     Key => symmetricAlgebra,
     Headline => "the symmetric algebra of a module",
     TT "symmetricAlgebra M", " -- produces the symmetric algebra of a
     module M.",
     PARA{},
     "Bugs: uses symbols from the beginning of the alphabet as variables in
     the new ring; makes a quotient ring when it doesn't have to."
     }

document {
     Key => NonLinear,
     Headline => "use the algorithm which doesn't assume that the ring map is linear",
     TT "Strategy => NonLinear", " -- an option value for the ", TO "Strategy", "
     option to ", TO "pushForward1", "."
     }

document {
     Key => [pushForward1,StopBeforeComputation],
     Headline => "initialize but do not begin the computation",
     TT "StopBeforeComputation", " -- keyword for an optional argument used with
     ", TO "pushForward1", ".",
     PARA{},
     "Tells whether to start the computation, with the default value
     being ", TT "true", "."
     }

document {
     Key => [pushForward1,DegreeLimit],
     Headline => "compute only up to this degree",
     TT "DegreeLimit => n", " -- keyword for an optional argument used with
     ", TO "pushForward1", " which specifies that the computation should halt after dealing 
     with degree ", TT "n", ".",
     PARA{},
     "This option is relevant only for homogeneous matrices.",
     PARA{},
     "The maximum degree to which to compute is computed in terms of the
     degrees of the ring map, ", TT "f", ".  For example, if ", TT "f", "
     consists of cubics, then to find a quadratic relation, this option
     should be set to at least 6, by specifying, for example, ", 
     TT "DegreeLimit => 6", ".  The default is ", TT "infinity", ".",
     SeeAlso => {"pushForward1", "DegreeLimit"}
     }

document {
     Key => pushForward1,
     Headline => "the main computational component of pushForward",
     TT "pushForward1(f,M,options)", " -- Given a ring map f : R --> S, and an S-module
     M, yields a presentation matrix of the R-submodule of M generated by the given
     (S-module) generators of M.",
     PARA{},
     "Warning: this function will be removed, and its function incorporated into
     that of ", TO "image", " and ", TO "prune", ".",
     PARA{},
     "This is a very basic operation, and is used by several other functions.  See,
     for example, ", TO "pushForward", ".  Therefore we intend to eliminate it,
     and merge its function into ", TO "image", " after introducing
     generalized module homomorphisms which map an R-module to an S-module.",
     PARA{},
     "As an example, the following fragment computes the ideal of the
     rational normal curve. This could also be done using ", TO "monomialCurveIdeal", ".",
     EXAMPLE {
	  "R = ZZ/101[a..d];",
      	  "S = ZZ/101[s,t];",
      	  "f = map(S,R,matrix{{s^4, s^3*t, s*t^3, t^4}})",
      	  "pushForward1(f,S^1)",
	  },
     PARA{},
     "The following code performs the Groebner computation using a product order 
     rather than the default elimination order.",
     EXAMPLE "pushForward1(f,S^1,MonomialOrder=>ProductOrder)",
     PARA{},
     "The computation is stashed inside the ring map, until the computation has
     finished completely.  This means that you may interrupt this command, and 
     later restart it. You may alo obtain partial results, as follows.",
     EXAMPLE {
	  "f = map(S,R,matrix{{s^4, s^3*t, s*t^3, t^4}})",
      	  "pushForward1(f,S^1,DegreeLimit=>4)",
	  },
     "After interrupting a computation (using control-C), you may view the
     equations so far obtained by using the ", TT "PairLimit", " option to prevent any
     further work from being done.",
     EXAMPLE "pushForward1(f,S^1,PairLimit=>0)",
     "The type ", TO "PushforwardComputation", " is used internally by our current implementation.",
     }

document {
     Key => [pushForward1,StopWithMinimalGenerators],
     Headline => "stop when minimal generators have been determined",
     TT "StopWithMinimalGenerators => true", " -- an option for ", TO "pushForward1", "
     that specifies that the computation should stop as soon as a
     complete list of minimal generators for the submodule or ideal has been
     determined.",
     PARA{},
     "The value provided is simply passed on to ", TO "gb", ": see 
     ", TO [gb,StopWithMinimalGenerators], " for details."
     }

document {
     Key => [pushForward1,PairLimit],
     Headline => "stop when this number of pairs is handled",
     TT "PairLimit => n", " -- keyword for an optional argument used with
     ", TO "pushForward1", ", which specifies that the computation should
     be stopped after a certain number of S-pairs have been reduced."
     }

document {
     Key => [pushForward1,MonomialOrder],
     Headline => "specify the elimination order to use in pushForward1",
     TT "MonomialOrder => x", " -- a keyword for an optional argument to ", TO "pushForward1", "
     which tells which monomial order to use for the Groebner basis computation
     involved.",
     PARA{},
     "Possible values:",
     UL {
	  (TT "MonomialOrder => EliminationOrder", " -- use the natural elimination order (the default)"),
	  (TT "MonomialOrder => ProductOrder", " -- use the product order"),
	  (TT "MonomialOrder => LexOrder", " -- use lexical order"),
	  },
     SeeAlso => "EliminationOrder"
     }

document {
     Key => [pushForward1,UseHilbertFunction],
     Headline => "whether to use knowledge of the Hilbert function",
     TT "UseHilbertFunction => true", " -- a keyword for an optional argument to
     ", TO "pushForward1", " which specifies whether to use the Hilbert function,
     if one has previously been computed.",
     PARA{},
     "The default is to use it if possible."
     }

document {
     Key => [pushForward1,Strategy],
     Headline => "specify which algorithm to use in the computation",
     TT "pushForward1(f,M,Strategy => v)", " -- an option for ", TO pushForward1, " 
     which can be used to specify the strategy to be used in the computation.",
     PARA{},
     "The strategy option value ", TT "v", " should be one of the following.",
     UL {
	  TO "NonLinear",
     	  TO "Linear"
	  },
     PARA{},
     "The default is for the code to select the best strategy heuristically."
     }

document {
     Key => PushforwardComputation,
     Headline => "a type of list used internally by pushForward1",
     TT "PushforwardComputation", " -- a type of list used internally by
     ", TO "pushForward1", "."
     }

document {
     Key => EliminationOrder,
     Headline => "use the natural elmination order in a pushForward1 computation",
     TT "EliminationOrder", " -- a value for the ", TO "MonomialOrder", "
     option to ", TO "pushForward1", " which specifies the natural elimination
     order be used."
     }

document {
     Key => pushForward,
     TT "pushForward(f,M)", " -- yields an R-presentation of the S-module ", TT "M", ", where
     ", TT "f:R --> S", " is a ring map, and ", TT "M", " is considered as 
     an ", TT "R", "-module via ", TT "f", ".",
     PARA{},
     "If ", TT "M", " is not finitely generated over ", TT "R", ", then an error is raised.",
     PARA{},
     "Currently, ", TT "R", " and ", TT "S", " must both be polynomial rings over the same base field."
     }

document {
     Key => [pushForward,StopBeforeComputation],
     TT "StopBeforeComputation => false", " -- an optional argument used with
     ", TO "pushForward", ".",
     PARA{},
     "Tells whether to start the computation, with the default value
     being ", TT "true", "."
     }

document {
     Key => [pushForward,StopWithMinimalGenerators],
     TT "StopWithMinimalGenerators => true", " -- an option for ", TO "pushForward", "
     that specifies that the computation should stop as soon as a
     complete list of minimal generators for the submodule or ideal has been
     determined.",
     PARA{},
     "The value provided is simply passed on to ", TO "gb", ": see 
     ", TO [gb,StopWithMinimalGenerators], " for details."
     }

document {
     Key => [pushForward,Strategy],
     TT "pushForward(f,M,Strategy => v)", " -- an option for ", TO pushForward, " 
     which can be used to specify the strategy to be used in the computation.",
     PARA{},
     "The strategy option value ", TT "v", " should be one of the following.",
     UL {
	  TO "NonLinear",
     	  TO "Linear"
	  }
     }

TEST "
    R = ZZ/101[a,b]
    S = ZZ/101[a,b,c]
    M = cokernel matrix{{c^3}}
    f = map(S,R)
    assert( R^{0,-1,-2} == pushForward(f,M) )
"

document {
     Key => UseHilbertFunction,
     TT "UseHilbertFunction", " -- an option for ", TO "pushForward1", "."
     }
