document {
     Key => (symbol **, RingMap, Module),
     Headline => "tensor product of a module via a ring map",
     Usage => "f ** M",
     Inputs => {
	  "f" => { "a ring map from ", TT "R", " to ", TT "S" },
	  "M" => { "an ", TT "R", "-module" }
	  },
     Outputs => {
	  { "the tensor product of ", TT "M", " with ", TT "S", " over ", TT "R" }
	  },
     EXAMPLE {
	  "R = QQ[x,y];",
	  "S = QQ[t];",
	  "f = map(S,R,{t^2,t^3})",
	  "f ** coker vars R",
	  "f ** image vars R"
	  },
     SeeAlso => { (symbol " ", RingMap, Module) }
     }

document {
     Key => (symbol " ", RingMap, Module),
     Headline => "apply a ring map to a submodule of a free module",
     Usage => "f M",
     Inputs => {
	  "f" => { "a ring map from ", TT "R", " to ", TT "S", "." },
	  "M" => { "a free ", TT "R", "-module ", TT "R^n", " or a submodule of one" }
	  },
     Outputs => {
	  { "the submodule of ", TT "S^n", " generated by the image of ", TT "M" }
	  },
     EXAMPLE {
	  "R = QQ[x,y];",
	  "S = QQ[t];",
	  "f = map(S,R,{t^2,t^3})",
	  "f image vars R"
	  },
     SeeAlso => { (symbol " ", RingMap, Module) }
     }

document {
     Key => DegreeMap,
     "A name for an optional argument used with ", TT "map", " when
     creating a ring map.",
     SeeAlso => { [map, DegreeMap] }
     }


document {
     Key => substitute,
     Headline => "substituting values for variables",
     TT "substitute(f,v)", " -- substitute values for the variables in the matrix,
     module, vector, polynomial, or monomial ", TT "f", " as specified by ", TT "v", ".", 
     PARA,
     "If ", TT "f", " is a matrix over ", TT "R", ", and ", TT "v", " is a 1 by k matrix over another
     ring ", TT "S", ", then the result is obtained by substituting the entries in ", TT "v", " 
     for the variables in ", TT "R", ".",
     PARA,
     "If ", TT "f", " is a module over ", TT "R", ", then substitution amounts to substitution
     in the matrices of generators and relations defining the module.  This is
     not the same as tensor product!",
     PARA,
     "If ", TT "v", " is a ring, then the result is obtained by substituting the variables of
     ", TT "v", " for the variables of R with the same name.  The substitution extends
     to the coefficient ring of ", TT "R", ", and so on.",
     PARA,
     "If ", TT "v", " is a list of options ", TT "{a => f, b => g, ...}", " then the 
     variable ", TT "a", " is replaced by the polynomial ", TT "f", ", etc.  Warning: 
     this may lead to surprising results if the ring containing f and g doesn't have 
     the same coefficient ring as the ring containing f, because currently no checking 
     is done to see whether the substitution requested corresponds to a well-defined
     ring homomorphism.",
     EXAMPLE {
	  "R = ZZ/101[x,y,z]",
      	  "f = x+2*y+3*z",
      	  "substitute(f,{x=>x^3, y=>y^3})",
      	  "S = ZZ/101[z,y,x]",
      	  "substitute(f,S)"
	  },
     "Warning: the specified substitution is not checked to see whether
     the corresponding ring homomorphism is well-defined; this may produce
     surprising results, especially if rational coefficients are converted
     to integer coefficients.",
     PARA,
     "A convenient abbreviation for ", TO "substitute", " is ", TO "sub", "."
     }

document {
     Key => graphIdeal,
     Headline => "the ideal of the graph of a ring map",
     TT "graphIdeal f", " -- provides the ideal of the graph of the map
     associated to the ring map f.",
     SeeAlso => "graphRing"
     }

document {
     Key => graphRing,
     Headline => "the ring of the graph of a ring map",
     TT "graphRing f", " -- provides the ring of the graph of the map
     associated to the ring map f.",
     SeeAlso => "graphIdeal"
     }

document {
     Key => symmetricAlgebra,
     Headline => "the symmetric algebra of a module",
     TT "symmetricAlgebra M", " -- produces the symmetric algebra of a
     module M.",
     PARA,
     "Bugs: uses symbols from the beginning of the alphabet as variables in
     the new ring; makes a quotient ring when it doesn't have to."
     }

document {
     Key => NonLinear,
     Headline => "use the algorithm which doesn't assume that the ring map is linear",
     TT "Strategy => NonLinear", " -- an option value for the ", TO "Strategy", "
     option to ", TO "pushForward1", "."
     }

document {
     Key => [pushForward1,StopBeforeComputation],
     Headline => "initialize but do not begin the computation",
     TT "StopBeforeComputation", " -- keyword for an optional argument used with
     ", TO "pushForward1", ".",
     PARA,
     "Tells whether to start the computation, with the default value
     being ", TT "true", "."
     }

document {
     Key => [pushForward1,DegreeLimit],
     Headline => "compute only up to this degree",
     TT "DegreeLimit => n", " -- keyword for an optional argument used with
     ", TO "pushForward1", " which specifies that the computation should halt after dealing 
     with degree ", TT "n", ".",
     PARA,
     "This option is relevant only for homogeneous matrices.",
     PARA,
     "The maximum degree to which to compute is computed in terms of the
     degrees of the ring map, ", TT "f", ".  For example, if ", TT "f", "
     consists of cubics, then to find a quadratic relation, this option
     should be set to at least 6, by specifying, for example, ", 
     TT "DegreeLimit => 6", ".  The default is ", TT "infinity", ".",
     SeeAlso => {"pushForward1", "DegreeLimit"}
     }

document {
     Key => pushForward1,
     Headline => "the main computational component of pushForward",
     TT "pushForward1(f,M,options)", " -- Given a ring map f : R --> S, and an S-module
     M, yields a presentation matrix of the R-submodule of M generated by the given
     (S-module) generators of M.",
     PARA,
     "Warning: this function will be removed, and its function incorporated into
     that of ", TO "image", " and ", TO "prune", ".",
     PARA,
     "This is a very basic operation, and is used by several other functions.  See,
     for example, ", TO "pushForward", ".  Therefore we intend to eliminate it,
     and merge its function into ", TO "image", " after introducing
     generalized module homomorphisms which map an R-module to an S-module.",
     PARA,
     "As an example, the following fragment computes the ideal of the
     rational normal curve. This could also be done using ", TO "monomialCurveIdeal", ".",
     EXAMPLE {
	  "R = ZZ/101[a..d];",
      	  "S = ZZ/101[s,t];",
      	  "f = map(S,R,matrix{{s^4, s^3*t, s*t^3, t^4}})",
      	  "pushForward1(f,S^1)",
	  },
     PARA,
     "The following code performs the Groebner computation using a product order 
     rather than the default elimination order.",
     EXAMPLE "pushForward1(f,S^1,MonomialOrder=>ProductOrder)",
     PARA,
     "The computation is stashed inside the ring map, until the computation has
     finished completely.  This means that you may interrupt this command, and 
     later restart it. You may alo obtain partial results, as follows.",
     EXAMPLE {
	  "f = map(S,R,matrix{{s^4, s^3*t, s*t^3, t^4}})",
      	  "pushForward1(f,S^1,DegreeLimit=>4)",
	  },
     "After interrupting a computation (using control-C), you may view the
     equations so far obtained by using the ", TT "PairLimit", " option to prevent any
     further work from being done.",
     EXAMPLE "pushForward1(f,S^1,PairLimit=>0)",
     "The type ", TO "PushforwardComputation", " is used internally by our current implementation.",
     }

document {
     Key => [pushForward1,StopWithMinimalGenerators],
     Headline => "stop when minimal generators have been determined",
     TT "StopWithMinimalGenerators => true", " -- an option for ", TO "pushForward1", "
     that specifies that the computation should stop as soon as a
     complete list of minimal generators for the submodule or ideal has been
     determined.",
     PARA,
     "The value provided is simply passed on to ", TO "gb", ": see 
     ", TO [gb,StopWithMinimalGenerators], " for details."
     }

document {
     Key => [pushForward1,PairLimit],
     Headline => "stop when this number of pairs is handled",
     TT "PairLimit => n", " -- keyword for an optional argument used with
     ", TO "pushForward1", ", which specifies that the computation should
     be stopped after a certain number of S-pairs have been reduced."
     }

document {
     Key => [pushForward1,MonomialOrder],
     Headline => "specify the elimination order to use in pushForward1",
     TT "MonomialOrder => x", " -- a keyword for an optional argument to ", TO "pushForward1", "
     which tells which monomial order to use for the Groebner basis computation
     involved.",
     PARA,
     "Possible values:",
     UL {
	  (TT "MonomialOrder => EliminationOrder", " -- use the natural elimination order (the default)"),
	  (TT "MonomialOrder => ProductOrder", " -- use the product order"),
	  (TT "MonomialOrder => LexOrder", " -- use lexical order"),
	  },
     SeeAlso => "EliminationOrder"
     }

document {
     Key => [pushForward1,UseHilbertFunction],
     Headline => "whether to use knowledge of the Hilbert function",
     TT "UseHilbertFunction => true", " -- a keyword for an optional argument to
     ", TO "pushForward1", " which specifies whether to use the Hilbert function,
     if one has previously been computed.",
     PARA,
     "The default is to use it if possible."
     }

document {
     Key => [pushForward1,Strategy],
     Headline => "specify which algorithm to use in the computation",
     TT "pushForward1(f,M,Strategy => v)", " -- an option for ", TO pushForward1, " 
     which can be used to specify the strategy to be used in the computation.",
     PARA,
     "The strategy option value ", TT "v", " should be one of the following.",
     UL {
	  TO "NonLinear",
     	  TO "Linear"
	  },
     PARA,
     "The default is for the code to select the best strategy heuristically."
     }

document {
     Key => PushforwardComputation,
     Headline => "a type of list used internally by pushForward1",
     TT "PushforwardComputation", " -- a type of list used internally by
     ", TO "pushForward1", "."
     }

document {
     Key => EliminationOrder,
     Headline => "use the natural elmination order in a pushForward1 computation",
     TT "EliminationOrder", " -- a value for the ", TO "MonomialOrder", "
     option to ", TO "pushForward1", " which specifies the natural elimination
     order be used."
     }

document {
     Key => pushForward,
     TT "pushForward(f,M)", " -- yields an R-presentation of the S-module ", TT "M", ", where
     ", TT "f:R --> S", " is a ring map, and ", TT "M", " is considered as 
     an ", TT "R", "-module via ", TT "f", ".",
     PARA,
     "If ", TT "M", " is not finitely generated over ", TT "R", ", then an error is raised.",
     PARA,
     "Currently, ", TT "R", " and ", TT "S", " must both be polynomial rings over the same base field."
     }

document {
     Key => [pushForward,StopBeforeComputation],
     TT "StopBeforeComputation => false", " -- an optional argument used with
     ", TO "pushForward", ".",
     PARA,
     "Tells whether to start the computation, with the default value
     being ", TT "true", "."
     }

document {
     Key => [pushForward,StopWithMinimalGenerators],
     TT "StopWithMinimalGenerators => true", " -- an option for ", TO "pushForward", "
     that specifies that the computation should stop as soon as a
     complete list of minimal generators for the submodule or ideal has been
     determined.",
     PARA,
     "The value provided is simply passed on to ", TO "gb", ": see 
     ", TO [gb,StopWithMinimalGenerators], " for details."
     }

document {
     Key => [pushForward,Strategy],
     TT "pushForward(f,M,Strategy => v)", " -- an option for ", TO pushForward, " 
     which can be used to specify the strategy to be used in the computation.",
     PARA,
     "The strategy option value ", TT "v", " should be one of the following.",
     UL {
	  TO "NonLinear",
     	  TO "Linear"
	  }
     }

TEST "
    R = ZZ/101[a,b]
    S = ZZ/101[a,b,c]
    M = cokernel matrix{{c^3}}
    f = map(S,R)
    assert( R^{0,-1,-2} == pushForward(f,M) )
"

document {
     Key => UseHilbertFunction,
     TT "UseHilbertFunction", " -- an option for ", TO "pushForward1", "."
     }
