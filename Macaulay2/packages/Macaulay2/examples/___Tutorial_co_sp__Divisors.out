--warning: checksum has changed for a map
--package "Macaulay2Core" loaded
--package "PrimaryDecomposition" loaded
--loading the Macaulay2 documentation
--package "Macaulay2" loaded

i1 : KK = ZZ/31991

o1 = KK

o1 : QuotientRing

i2 : SE = KK[x,y,z]/(y^2*z - x*(x-z)*(x+3*z))

o2 = SE

o2 : QuotientRing

i3 : purify1S2 = I -> (
         -- Assuming ring I is S2, and I is not 0, returns the 
         -- pure codimension 1 part of I.
         -- Find a nonzero element of I:
         M := compress gens I;
         -- Explanation: gens I is 
         -- the matrix of generators of I; compress
         -- removes the entries that are 0
         -- and := makes M a local variable.
         if numgens source M == 0 then error "Ideal is zero!";
         f := ideal(M_(0,0));   
         -- f is the ideal generated by the first entry.
         -- Since ring I is S2, the ideal f is 
         -- pure codimension 1.  Thus
         f:(f:I)
         -- is the pure codimension 1 part. (The last 
         -- expression given in a function is the returned
         -- value.  The symbol ; is the statement separator so
         -- (by definition!) we cannot put a ; after the last expression.
         )

o3 = purify1S2

o3 : Function

i4 : R = ZZ/5[a,b]

o4 = R

o4 : PolynomialRing

i5 : purify1S2(ideal(a^2,a*b))

o5 = ideal(a)

o5 : Ideal of R

i6 : Divisor = new Type of List

o6 = Divisor

o6 : Type

i7 : divisor = method()

o7 = divisor

o7 : Function

i8 : divisor(Ideal,Ideal) := (I,J) -> 
         new Divisor from {purify1S2 I,purify1S2 J}

o8 = --Function[stdio:27:30-28:44]--

o8 : Function

i9 : divisor Ideal := (I) -> divisor(I, ideal(1_(ring I)))

o9 = --Function[stdio:29:21-29:49]--

o9 : Function

i10 : P = divisor ideal(x,z)

o10 = {ideal (z, x), ideal 1}

o10 : Divisor

i11 : R = divisor ideal(x,y)

o11 = {ideal (y, x), ideal 1}

o11 : Divisor

i12 : R1 = divisor ideal(x-z,y)

o12 = {ideal (y, x - z), ideal 1}

o12 : Divisor

i13 : R2 = divisor ideal(x+3*z,y)

o13 = {ideal (y, x + 3z), ideal 1}

o13 : Divisor

i14 : Q1 = divisor ideal(y-6*z, x-3*z)

o14 = {ideal (y - 6z, x - 3z), ideal 1}

o14 : Divisor

i15 : normalForm = method()

o15 = normalForm

o15 : Function

i16 : normalForm Divisor := (D) -> 
         new Divisor from {D#0 : D#1, D#1 : D#0}

o16 = --Function[stdio:36:26-37:40]--

o16 : Function

i17 : Divisor == Divisor := (D,E) -> (
          D1 := normalForm D;
          E1 := normalForm E;
          D1#0 == E1#0 and D1#1 == E1#1
          )

o17 = --Function[stdio:38:28-41:32]--

o17 : Function

i18 : D = divisor(ideal(y, x^2+2*x*z-3*z^2), ideal(x-z, y))

                  2            2
o18 = {ideal (y, x  + 2x*z - 3z ), ideal (y, x - z)}

o18 : Divisor

i19 : normalForm D

o19 = {ideal (y, x + 3z), ideal 1}

o19 : Divisor

i20 : D == R2

o20 = false

o20 : Boolean

i21 : Divisor + Divisor := (D,E) -> divisor(D#0 * E#0, D#1 * E#1);

i22 : - Divisor := (D) -> new Divisor from {D#1, D#0}

o22 = --Function[stdio:47:17-47:45]--

o22 : Function

i23 : Divisor - Divisor := (D,E) -> D + (-E);

i24 : ZZ Divisor := ZZ * Divisor := (n,D) -> divisor((D#0)^n, (D#1)^n);

i25 : 2P

                  2
o25 = {ideal (z, x ), ideal 1}

o25 : Divisor

i26 : 3P

o26 = {ideal(z), ideal 1}

o26 : Divisor

i27 : D = P-R1

o27 = {ideal (z, x), ideal (y, x - z)}

o27 : Divisor

i28 : D2 = 2P - 2R1

                  2                  2
o28 = {ideal (z, x ), ideal (x - z, y )}

o28 : Divisor

i29 : D = 2P

                  2
o29 = {ideal (z, x ), ideal 1}

o29 : Divisor

i30 : I = D#0

                 2
o30 = ideal (z, x )

o30 : Ideal of SE

i31 : J = D#1

o31 = ideal 1

o31 : Ideal of SE

i32 : f = z

o32 = z

o32 : SE

i33 : LD = basis(degree f, purify1S2((f*J) : I))

o33 = {1} | 1 0 |
      {1} | 0 1 |

o33 : Matrix

i34 : LD = super (LD ** (ring target LD))

o34 = | z x |

               1        2
o34 : Matrix SE  <--- SE

i35 : imI = purify1S2(((z+x)*I) : z)

                     2     2
o35 = ideal (x + z, y  - 4z )

o35 : Ideal of SE

i36 : degree imI

o36 = 2

i37 : globalSections = method()

o37 = globalSections

o37 : Function

i38 : globalSections Divisor := (D) -> (
          -- First let's grab the parts (I,J) of D.
          I := D#0;
          J := D#1;
          -- Let 'f' be the first element of the 
          -- matrix of generators of the ideal I.
          f := (gens I)_(0,0);
          -- Now compute the basis of global sections
          -- just as above
          LD := basis(degree f, purify1S2((f*J) : I));
          LD = super (LD ** (ring target LD));
          -- Return both this vector space and the denominator
          {LD, f});

i39 : sectionIdeal = (f,g,D) -> (
          I := D#0;
          J := D#1;
          purify1S2((f*I):g) : J
          );

i40 : D = 4P

               2
o40 = {ideal (z , x*z), ideal 1}

o40 : Divisor

i41 : L = globalSections D

                         2
o41 = {| xz yz z2 x2 |, z }

o41 : List

i42 : phi = map(SE, ZZ/31991[a..d], L#0)

               ZZ                           2   2
o42 = map(SE,----- [a, b, c, d],{x*z, y*z, z , x })
             31991

                        ZZ
o42 : RingMap SE <--- ----- [a, b, c, d]
                      31991

i43 : ker phi

              2                       2
o43 = ideal (b  + 3a*c - a*d - 2c*d, a  - c*d)

                 ZZ
o43 : Ideal of ----- [a, b, c, d]
               31991

i44 : D = 4P - R

               2
o44 = {ideal (z , x*z), ideal (y, x)}

o44 : Divisor

i45 : L = globalSections D

                      2
o45 = {| yz xz x2 |, z }

o45 : List

i46 : II = sectionIdeal(y*z+x*z+x^2, z^2, D)

              2                  2                2   2
o46 = ideal (y  + 3x*z + y*z + 3z , x*y + x*z - 3z , x  + x*z + y*z)

o46 : Ideal of SE

i47 : degree II

o47 = 3

i48 : globalSections (P-R)

o48 = {0, z}

o48 : List

i49 : D = 2 P - 2 R

                  2              2
o49 = {ideal (z, x ), ideal (x, y )}

o49 : Divisor

i50 : LB = globalSections D

o50 = {| x |, z}

o50 : List

i51 : linearlyEquivalent = (D,E) -> (
          F := normalForm(D-E);
          LB := globalSections F;
          L := LB#0;
          -- L is the matrix of numerators. Thus numgens source L
          -- is the dimension of the space of global sections.
          if numgens source L != 1 
          then false
          else (
              R := ring L;
              V := sectionIdeal(L_(0,0), LB#1, F);
              if V == ideal(1_R) 
                then (L_(0,0))/(LB#1) 
                else false)
          );

i52 : linearlyEquivalent(P,R)

o52 = false

o52 : Boolean

i53 : linearlyEquivalent(2P,2R)

      x
o53 = -
      z

o53 : frac(SE)

i54 : effective = (D) -> (
          LB := globalSections D;
          L := LB#0;  -- the matrix of numerators
          if numgens source L == 0 
          then error(toString D + " is not effective")
          else divisor sectionIdeal(L_(0,0), LB#1, D));

i55 : effective(2R-P)

o55 = {ideal (z, x), ideal 1}

o55 : Divisor

i56 : addition = (R,S) -> effective(R + S - P);

i57 : addition(R1,R2)

o57 = {ideal (y, x), ideal 1}

o57 : Divisor

i58 : Q2 = addition(Q1, Q1)

o58 = {ideal (y, x - z), ideal 1}

o58 : Divisor

i59 : Q3 = addition(Q2, Q1)

o59 = {ideal (y + 6z, x - 3z), ideal 1}

o59 : Divisor

i60 : Q4 = addition(Q3, Q1)

o60 = {ideal (z, x), ideal 1}

o60 : Divisor

i61 : Q4a = addition(Q2,Q2)

o61 = {ideal (z, x), ideal 1}

o61 : Divisor

i62 : S = ZZ/31991[a,b,c,d];

i63 : catalect = map(S^2, 3, (i,j)->S_(i+j))

o63 = | a b c |
      | b c d |

              2       3
o63 : Matrix S  <--- S

i64 : IC = minors(2, catalect)

                2                        2
o64 = ideal (- b  + a*c, - b*c + a*d, - c  + b*d)

o64 : Ideal of S

i65 : SX = S/IC

o65 = SX

o65 : QuotientRing

i66 : KX = Ext^2(coker gens IC,S^{-4})

o66 = cokernel {1} | c  b  a  |
               {1} | -d -c -b |

                             2
o66 : S-module, quotient of S

i67 : canpres = substitute(presentation(KX), SX)

o67 = {1} | c  b  a  |
      {1} | -d -c -b |

               2        3
o67 : Matrix SX  <--- SX

i68 : betti canpres

o68 = total: 2 3
          1: 2 3

i69 : I1 = transpose (syz transpose canpres)_{0}

o69 = | d c |

               1        2
o69 : Matrix SX  <--- SX

i70 : dg = (degrees (target I1))_0_0

o70 = 0

i71 : divisorFromModule = M -> (
        -- given a module M, returns the divisor of the image
        -- of a nonzero homomorphism to R, suitably twisted.
        -- first get the presentation of M
          I1 = transpose( 
             (syz transpose presentation M)_{0});
        -- The degree is
          d := (degrees (target I1))_0_0;
        -- We need to balance the degree d with a power
        -- of the first nonzero generator of the ring.
          var1 := (compress vars ring M)_{0};
        -- Now fix up the degrees.
          if d==0 then candiv = divisor(ideal I1) 
          else if d>0 then 
              candiv = 
                       divisor(
                        ideal (I1**dual(target I1)),
                        ideal var1^d
                       )                          
          else
              candiv = 
                 divisor(
                        ideal( 
                         var1^(-d)**I1**dual target I1
                        ))
      );

i72 : M = coker canpres

o72 = cokernel {1} | c  b  a  |
               {1} | -d -c -b |

                               2
o72 : SX-module, quotient of SX

i73 : divisorFromModule(M)

o73 = {ideal (d, c), ideal 1}

o73 : Divisor

i74 : use SX

o74 = SX

o74 : QuotientRing

i75 : divisorFromModule(image matrix{{d^2}})

                       2
o75 = {ideal 1, ideal(a )}

o75 : Divisor

i76 : divisorFromModule(SX^{1})

o76 = {ideal(a), ideal 1}

o76 : Divisor

i77 : canonicalDivisor= SX ->(
        -- Given a ring SX, computes a canonical divisor for SX
        I := ideal presentation SX;
        S := ring I;
        embcodim := codim I;
        M := Ext^embcodim(coker gens I,S^{-numgens S});
        M = coker substitute(presentation M, SX);
        divisorFromModule(M)
        );

i78 : canonicalDivisor SX

o78 = {ideal (d, c), ideal 1}

o78 : Divisor

i79 : 
