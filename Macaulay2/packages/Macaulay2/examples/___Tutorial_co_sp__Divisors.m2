KK = ZZ/31991
SE = KK[x,y,z]/(y^2*z - x*(x-z)*(x+3*z))
purify1S2 = I -> (
    -- Assuming ring I is S2, and I is not 0, returns the 
    -- pure codimension 1 part of I.
    -- Find a nonzero element of I:
    M := compress gens I;
    -- Explanation: gens I is 
    -- the matrix of generators of I; compress
    -- removes the entries that are 0
    -- and := makes M a local variable.
    if numgens source M == 0 then error "Ideal is zero!";
    f := ideal(M_(0,0));   
    -- f is the ideal generated by the first entry.
    -- Since ring I is S2, the ideal f is 
    -- pure codimension 1.  Thus
    f:(f:I)
    -- is the pure codimension 1 part. (The last 
    -- expression given in a function is the returned
    -- value.  The symbol ; is the statement separator so
    -- (by definition!) we cannot put a ; after the last expression.
    )
R = ZZ/5[a,b]
purify1S2(ideal(a^2,a*b))
Divisor = new Type of List
divisor = method()
divisor(Ideal,Ideal) := (I,J) -> 
    new Divisor from {purify1S2 I,purify1S2 J}
divisor Ideal := (I) -> divisor(I, ideal(1_(ring I)))
P = divisor ideal(x,z)
R = divisor ideal(x,y)
R1 = divisor ideal(x-z,y)
R2 = divisor ideal(x+3*z,y)
Q1 = divisor ideal(y-6*z, x-3*z)
normalForm = method()
normalForm Divisor := (D) -> 
   new Divisor from {D#0 : D#1, D#1 : D#0}
Divisor == Divisor := (D,E) -> (
    D1 := normalForm D;
    E1 := normalForm E;
    D1#0 == E1#0 and D1#1 == E1#1
    )
D = divisor(ideal(y, x^2+2*x*z-3*z^2), ideal(x-z, y))
normalForm D
D == R2
Divisor + Divisor := (D,E) -> divisor(D#0 * E#0, D#1 * E#1);
- Divisor := (D) -> new Divisor from {D#1, D#0}
Divisor - Divisor := (D,E) -> D + (-E);
ZZ Divisor := ZZ * Divisor := (n,D) -> divisor((D#0)^n, (D#1)^n);
2P
3P
D = P-R1
D2 = 2P - 2R1
D = 2P
I = D#0
J = D#1
f = z
LD = basis(degree f, purify1S2((f*J) : I))
LD = super (LD ** (ring target LD))
imI = purify1S2(((z+x)*I) : z)
degree imI
globalSections = method()
globalSections Divisor := (D) -> (
    -- First let's grab the parts (I,J) of D.
    I := D#0;
    J := D#1;
    -- Let 'f' be the first element of the 
    -- matrix of generators of the ideal I.
    f := (gens I)_(0,0);
    -- Now compute the basis of global sections
    -- just as above
    LD := basis(degree f, purify1S2((f*J) : I));
    LD = super (LD ** (ring target LD));
    -- Return both this vector space and the denominator
    {LD, f});
sectionIdeal = (f,g,D) -> (
    I := D#0;
    J := D#1;
    purify1S2((f*I):g) : J
    );
D = 4P
L = globalSections D
phi = map(SE, ZZ/31991[a..d], L#0)
ker phi
D = 4P - R
L = globalSections D
II = sectionIdeal(y*z+x*z+x^2, z^2, D)
degree II
globalSections (P-R)
D = 2 P - 2 R
LB = globalSections D
linearlyEquivalent = (D,E) -> (
    F := normalForm(D-E);
    LB := globalSections F;
    L := LB#0;
    -- L is the matrix of numerators. Thus numgens source L
    -- is the dimension of the space of global sections.
    if numgens source L != 1 
    then false
    else (
        R := ring L;
        V := sectionIdeal(L_(0,0), LB#1, F);
        if V == ideal(1_R) 
          then (L_(0,0))/(LB#1) 
          else false)
    );
linearlyEquivalent(P,R)
linearlyEquivalent(2P,2R)
effective = (D) -> (
    LB := globalSections D;
    L := LB#0;  -- the matrix of numerators
    if numgens source L == 0 
    then error(toString D + " is not effective")
    else divisor sectionIdeal(L_(0,0), LB#1, D));
effective(2R-P)
addition = (R,S) -> effective(R + S - P);
addition(R1,R2)
Q2 = addition(Q1, Q1)
Q3 = addition(Q2, Q1)
Q4 = addition(Q3, Q1)
Q4a = addition(Q2,Q2)
S = ZZ/31991[a,b,c,d];
catalect = map(S^2, 3, (i,j)->S_(i+j))
IC = minors(2, catalect)
SX = S/IC
KX = Ext^2(coker gens IC,S^{-4})
canpres = substitute(presentation(KX), SX)
betti canpres
I1 = transpose (syz transpose canpres)_{0}
dg = (degrees (target I1))_0_0
divisorFromModule = M -> (
  -- given a module M, returns the divisor of the image
  -- of a nonzero homomorphism to R, suitably twisted.
  -- first get the presentation of M
    I1 = transpose( 
       (syz transpose presentation M)_{0});
  -- The degree is
    d := (degrees (target I1))_0_0;
  -- We need to balance the degree d with a power
  -- of the first nonzero generator of the ring.
    var1 := (compress vars ring M)_{0};
  -- Now fix up the degrees.
    if d==0 then candiv = divisor(ideal I1) 
    else if d>0 then 
        candiv = 
                 divisor(
                  ideal (I1**dual(target I1)),
                  ideal var1^d
                 )                          
    else
        candiv = 
           divisor(
                  ideal( 
                   var1^(-d)**I1**dual target I1
                  ))
);
M = coker canpres
divisorFromModule(M)
use SX
divisorFromModule(image matrix{{d^2}})
divisorFromModule(SX^{1})
canonicalDivisor= SX ->(
  -- Given a ring SX, computes a canonical divisor for SX
  I := ideal presentation SX;
  S := ring I;
  embcodim := codim I;
  M := Ext^embcodim(coker gens I,S^{-numgens S});
  M = coker substitute(presentation M, SX);
  divisorFromModule(M)
  );
canonicalDivisor SX
