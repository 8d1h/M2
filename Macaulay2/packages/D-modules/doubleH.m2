-----------------------------------------------------------------------------------
-- double local cohomology: computes  H_m^i(H_I^j(R)) 
-- R = Q[x_1,...,x_n]
-- I: ideal in R
-- m = (x_1,...,x_n): ideal in R
-----------------------------------------------------------------------------------
doubleLocalCohom = method();
doubleLocalCohom(Ideal) := (I) -> (
     -- error checking to be added
     -- I is assumed to be an ideal in WA generated by polynomials
     f := first entries gens I;
     r := #f;
     W := ring I;
     n := numgens W // 2;
     createDpairs(W);
     xVar := (W.dpairVars)#0; 
     iSet := set toList (0..(n-1));
     jSet := set toList (0..(r-1));
     subISets := toList ((subsets iSet));
     subJSets := toList ((subsets jSet));
     --print(f, r, iSet, subISets);
             
     -- Step1.
     -- Calculate J^/delta( (F_/theta)^s ) and b^/delta_(F_/theta)(s)   for all /theta
     J := new MutableHashTable;
     bF := new MutableHashTable;
     scan(subISets, theta->(
     scan(subJSets, theta'->(  
	       if theta != {} or theta' != {} then (
		    F := product(theta, i->xVar#i)*product(theta', j->f#j);
	       	    print(theta, theta', F);
	       	    J#(theta, theta') = AnnFs F;
	       	    bF#(theta, theta') = globalBFunction F;
	       	    print(J#(theta, theta'), bF#(theta, theta'));
		    )
	       ))));
     
     -- Step 2.
     -- a = min integer root of all bF-s
     a := min flatten flatten (subISets / (theta ->(
		     subJSets / (theta'->(
	       		       if theta == {} or theta' == {} then {0}
			       else getIntRoots(bF#(theta, theta'))
			       )))));
     -- Substitute s = a in J-s
     scan(subISets, theta -> (
     scan(subJSets, theta'->(       
	       if theta == {} or theta' == {} then (
		    J#(theta, theta') = ideal W.dpairVars#1;
	       	    )
	       else(
		    AforS := map(W, ring J#(theta, theta'), matrix {{a_W}} | vars W);
	       	    print (J#(theta, theta') = AforS J#(theta, theta'));
		    )
	       ))));
     
     -- Step 3.
     -- Compute the double complex 
     C = new MutableHashTable;
     psi = new MutableHashTable;
     ksi = new MutableHashTable;
     
     scan(toList(0..r), j->(
     scan(toList(0..n), i->(
      	       l := select(subISets, u -> #u == i) / (theta -> (
		    select(subJSets, v -> #v == j) / (theta' -> (
			      (theta, theta') => W^1 / J#(theta, theta') 
			      ))));
	       print l;
	       C#(i,j) = directSum( flatten l );
	       ))));

     scan(toList(0..r-1), j->(
     scan(toList(0..n), i->(
     	       psi#(i, j) = map (C#(i,j+1), C#(i,j), (i',j') -> (
			 print ("i', j'", i',j');
			 i0 := (indices C#(i,j))_j';
			 j0 := (indices C#(i,j+1))_i';
			 if i0#0 == j0#0 and isSubset(i0#1, j0#1) 
			 then (
			      l := first toList (set j0#1 - set i0#1);
			      (-1)^(position(j0#1, u -> u == l)) * (f#l)^(-a)
			      )  
			 else 0_W
			 )
		    );   
	       ))));
     scan(toList(0..n), i->(
	       psi#(i, r) = map(W^0, C#(i,r), 0);
	       psi#(i, -1) = map(C#(i,0), W^0, 0);
	       ));
     scan(toList(-1..r), j->(
	       psi#(-1, j) = map(W^0,0);
	       psi#(n+1, j) = map(W^0, 0);
	       ));
     
     scan(toList(0..r), j->(
     scan(toList(0..n-1), i->(
     	       ksi#(i, j) = map (C#(i+1,j), C#(i,j), (i',j') -> (
		 	 i0 := (indices C#(i,j))_j';
			 j0 := (indices C#(i+1,j))_i';
			 if i0#1 == j0#1 and isSubset(i0#0, j0#0) 
			 then (
			      l := first toList (set j0#0 - set i0#0);
			      (-1)^(position(j0#0, u -> u == l)) * (xVar#l)^(-a)
			      )  
			 else 0_W
			 )
		    );   
	       ))));
     scan(toList(0..r), j->(
	       ksi#(n, j) = map (W^0, C#(n,j), 0);
	       ksi#(-1, j) = map (C#(0, j), W^0, 0);
	       ));
     scan(toList(-1..n), i->(
	       ksi#(i, -1) = map(W^0, 0);
	       ));
	
     -- Step 4.
     -- Compute the homology of the complex
     
     doubleH = new MutableHashTable;
     scan(toList(0..r), j->(
     scan(toList(0..n), i->(
	       print ("doubleH", i, j);
	       pList := { ksi#(i-1, j) , kernel psi#(i-1,j), image psi#(i, j-1) }; 
	       print pList;
	       print (pList / (u -> class u)); 
	       --pList = { C#(i-1, j), C#(i,j) };
	       --print pList;
	       --print (pList / (u -> class u)); 
	  
	  doubleH#(i,j) = 
	  ( intersect( kernel psi#(i,j), preimage(image psi#(i+1, j-1), ksi#(i,j)) ) 
	       + image psi#(i, j-1) ) 
	  /
	  ( image (ksi#(i-1, j) * map(source ksi#(i-1, j), kernel psi#(i-1,j))) + image psi#(i, j-1) )
	  ))));
     
     use W;
     doubleH
     );
