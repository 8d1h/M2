newPackage(
        "ToricIdeals",
        Version => "0.1", 
        Date => "26 Oct 2009",
        Authors => {{Name => "Mike Stillman", 
                  Email => "mike@math.cornell.edu", 
                  HomePage => "http://www.math.cornell.edu/~mike"}},
        Headline => "computing the ideal of a toric variety",
        DebuggingMode => true
        )

export { "toricIdeal", "saturators" }

needsPackage "LLLBases"

toBinomial = (b, S) -> (
     pos := 1_S;
     neg := 1_S;
     scan(#b, i -> if b_i > 0 then pos = pos*S_i^(b_i)
                   else if b_i < 0 then neg = neg*S_i^(-b_i));
     pos - neg);

toric = (B,S) -> ideal apply(entries transpose B, b -> toBinomial(b, S))

---------------------------
-- Finding saturators -----
---------------------------
makeHash = (J) -> (
     -- Input: J:Ideal, whose generators are binomials
     -- Output: MutableHashTable, key => value
     --   the key is the support set of vars of one monom, and
     --     the value is the support set of the opposite monomial
     -- Subroutine for 'saturators'
     H := new MutableHashTable;
     for i from 0 to numgens J - 1 do (
	  f := J_i;
	  a := set indices leadTerm f;
	  b := set indices (f-leadTerm f);
	  if H#?a then H#a = H#a + b else H#a = b;
	  if H#?b then H#b = H#b + a else H#b = a;
	  );
     new HashTable from H)

findSaturators = (H) -> (
     -- H is a hash table like that coming from makeHash
     k := keys H;
     d := min apply(k, x -> #x);
     k1 := select(k, x -> #x === d);
     e := max apply(k1, x -> #H#x);
     k2 := select(k1, x -> #H#x === e);
     k2#0)

grabSaturators = (H,satvars) -> (
     -- H:HashTable
     -- satvars:List
     -- return (H,allvars)
     allvars := set satvars;
     while (
	  freebies = set {};
     	  H' := new MutableHashTable;
	  scan(keys H, k -> (
		    k1 := k - allvars;
		    t := H#k - allvars;
		    if #k1 === 0
		    then freebies = freebies + t
		    else if #t > 0 then (
			 if H'#?k1 then H'#k1 = H'#k1 + t
		         else H'#k1 = t)));
     	  H = new HashTable from H';
	  #freebies > 0
	  ) do
          allvars = allvars + freebies;
     (H,toList allvars)
     )

saturators = method()
saturators Ideal := (J) -> (
     -- assumption: J is an ideal generated by binomials
     -- returns: list of variables X in the ring such that
     -- saturate(J, product of all vars) == saturate(J, product of vars in X)
     R := ring J;
     n := numgens R;
     H := makeHash J;
     satvars := set{};
     while #H > 0 do (
	  v := findSaturators H;
	  satvars = satvars + v;
	  (H,w) = grabSaturators(H,toList v);
	  );
     apply(sort toList satvars, i -> R_i))

------------------------
-- The 4ti2 version ----
------------------------

-- to be written

toricIdeal4ti2 = (A,R) -> (
     P := needsPackage "FourTiTwo";
     toricMarkov := value P.Dictionary#"toricMarkov";
     toricMarkov(A,R)
     )

------------------------
-- The main routine ----
------------------------

toricIdeal = method(Options => {Strategy=>null, CoefficientRing => ZZ/5, Variable => global x, Verbose => 0})

toricIdeal(Matrix, Ring) := opts -> (A,R) -> (
     if opts.Strategy === 4
       then return toricIdeal4ti2(A,R);
     n := numColumns A;
     B := transpose LLL matrix syz A;
     J := ideal apply(entries B, b -> toBinomial(b, R));
     satvars := saturators J;
     if opts.Verbose > 0 then 
       << "  -- using saturators: " << satvars << endl;
     if opts.Verbose <= 1 then
       scan(satvars, r -> J = saturate(J, r))
     else (
       scan(satvars, r -> (
		 << "  -- saturating with variable " << r << endl;
		 t := timing (J = saturate(J, r));
		 << "    -- time: " << t#0 << " seconds" << endl;));
       );
     J);

toricIdeal Matrix := opts -> (M) -> (
     -- first create a ring
     -- then call the other version
     kk := opts.CoefficientRing;
     x := opts.Variable;
     n := numColumns M;
     R := kk (monoid [x_1..x_n]);
     toricIdeal(M,R,opts)
     )

beginDocumentation()

doc ///
Key
  ToricIdeals
Headline
  computing the ideal of a projective (possibly non-normal) toric variety
Description
  Text
  Example
Caveat
SeeAlso
///

doc ///
Key
  toricIdeal
  (toricIdeal,Matrix)
  (toricIdeal,Matrix,Ring)
Headline
  find the toric ideal
Usage
  toricIdeal A
  toricIdeal(A,R)
Inputs
  A:Matrix
    a $d \times{} n$ matrix over ZZ
  R:Ring
    a polynomial ring.  If not given, a poly ring over QQ is created
Outputs
  :Ideal
    in the ring $R$.
Description
  Text
    Assuming that $R$ is a polynomial ring containing $n$ variables,
    then the result is an ideal $J \subset R$ such that $R/J = k[m_1, \ldots, m_n]$,
    where $m_i$ is the monomial in a poly ring with $d$ variables whose
    exponent vector is the $i$th column of $A$.
    
  Example
    R = QQ[a..e]
    A = matrix"
      1,1,1,1,1;
      1,2,3,4,5"
    toricIdeal(A,R)
    toricIdeal(A,R,Verbose=>2)
  Text
    See the book B. Sturmfels, "Convex Polytopes and Groebner bases", for more information.
Caveat
  The 4ti2 interface is not in place yet
SeeAlso
  LLLBases
///

TEST ///
restart
loadPackage "ToricIdeals"
A = matrix"1,1,1,1,1;
           1,2,3,4,5;
	   1,4,9,16,25"
R = ZZ/32003[a..e]
J = toricIdeal(A,R,Verbose=>2)
J = toricIdeal(A,R)
assert(J == ideal"ad2-b2e,bd3-c3e,ac3-b3d")
J1 = toricIdeal(A,R,Strategy=>4)
assert(J == J1)
///


end
restart
loadPackage "ToricIdeals"
installPackage(ToricIdeals, AbsoluteLinks=>false) -- need to do this for bug in 1.3
installPackage(ToricIdeals)
viewHelp ToricIdeals

