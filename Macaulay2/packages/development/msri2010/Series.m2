--================
-- THIS IS NOT A PACKAGE YET!
--
--================
--series(rational function) = series(polynomial)
--series(n,polynomial)
--series(Hilbert)
--series(generating function)
--series(degree, poly)


--arithmetic addion 
--reduction for series not in exact for
--set global default
--handle polys. 
--handle 


Series = new Type of HashTable
expression Series := s -> expression "O(" expression(s#degree+1) expression ")" + expression s#series;
net Series := s -> net expression s;
toString Series := s -> toString expression s;
tex Series := s -> tex expression s;
html Series := s -> html expression s;


series = method()
series(ZZ, RingElement) := Series => (n,f) -> (
     df := denominator f;
     nf := numerator f;
     degnf := first degree nf;
     degdf := first degree df;
     dC := (coefficients(df,Monomials=>apply(0..n,i->x^i)))_1;
     if not isUnit dC_(0,0) then error "lowest degree coefficient not a unit";
     a := i -> if i == 0 then (dC_(0,0))^(-1) else (dC_(0,0))^(-1)*sum(1..i, j -> -dC_(j,0)*a(i-j));    
     s := sum select(terms (nf * sum(0..n,i -> a(i) * x^i)), i -> first degree i <= n);
     new Series from {rationalFunction => f, degree => n, series => s}
     );

seriesOLD = method()
seriesOLD(ZZ, RingElement) := PowerSeries => (n,f) -> (
     df := denominator f;
     nf := numerator f;
     c := coefficient(1_(ring df), df); -- pulls out constant term
     s := sum select(terms lift(nf*(1/c)*sum(n+1, i -> (1-df/c)^i), ring df), i -> first degree i <= n);
     new Series from {rationalFunction => f, degree => n, series => s}
     );


series(ZZ, Function) := Series => (n,f) -> (
     s := sum for i from 0 to n if f i == 0 then continue else if first degree f i > n list f i do i = i+1;
     new Series from {genTerm => f, degree => n, series => s}
     );


series(ZZ, Function) := Series => (n,f) -> (
     i := 0;
     s := sum while first degree f i <= n list f i do i = i+1;
     new Series from {genTerm => f, degree => n, series => s}
     );
A = ZZ/5051[x]
series(10, n -> n*x^(5*n))



f = i -> if 1*x^i if i == 0 else 
i = 0
n = 8


viewHelp

first degree f 4

first degree(0_A) <= 8



series(ZZ, RingElement) := Series => (n,f) -> (
     sum(0..n, f);
     new Series from {genFunction => f, degree => first degree f n, series => sum(n+1,f)}
     );








installPackage "FormalGroupLaws"

ZZ/17[x]
f = series(1+x+x^2+x^4,3)
f*f
peek f





--series(RingElement,ZZ) := (s,n) -> 
--	(
--	if n<0 then error "The second argument should be a nonnegative integer."
--	else if instance(class(s),PolynomialRing)==false then error "The first element of the list should be an element of a polynomial ring."
--	else new FormalSeries from {part(0,n,numgens(class(s)) : 1,s),n} 
--	);





f = i -> x^i
g = i -> x^(i+1)
h = i -> f(i) + g(i)

-- is there a way to add ps which are generated by functions by ones
-- generated by rational functions or polynomials?




toPolynomial = s -> s#series;

-- this needs work, we have 3 types of powerseries. The generator should be preserved whenever possible. 
-- 
-- A new command called "decider" might be in order. 

Series+Series := (x,y) -> new Series from {generator = decider(x,y), degree => min(x#degree,y#degree), series => x+y}; -- not right
Series*Series := (x,y) -> new Series from {generator = decider(x,y), degree => min(x#degree,y#degree), series => x*y}; -- not right




R = ZZ/17[x,y]
g = series(1,1/(1+x+y))
f = series(10,1/(1-x))
peek f
toPolynomial(f)

class f


f*g
f+g

benchmark "f*g"
ff*gg
R = QQ[x,y]
I = (ideal vars R)^11
S = R/I
(1+2*x +3*x+5*y^3)^(-1)
gg = (1+x+y)^(-1)
ff = (1-x)^(-1)
benchmark "ff * gg"
--multiplication in the engine with truncation. 
--power series ring


-----------------------------------------------------------------------------

--=========================================================================--
--=========================================================================--
--=========================================================================--


Puiseux series
sqrt of rational function
nth root of rational function

parent class(1/x)
generatror (ring element) 
instance(ring f,FractionField)

could replace the 1/x with a pair, (1/x,FractionField)

