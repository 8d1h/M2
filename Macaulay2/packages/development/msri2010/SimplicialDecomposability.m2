-------------------
-- Package Header
-------------------
needsPackage "Depth";
needsPackage "SimplicialComplexes";
newPackage (
    "SimplicialDecomposability",
    Version => "0.0.1",
    Date => "10. January 2010",
    Authors => {{Name => "David W. Cook II", Email => "dcook@ms.uky.edu", HomePage => "http://www.ms.uky.edu/~dcook"}},
    Headline => "Pure k-Decomposability for simplicial complexes.",
    DebuggingMode => true
);
needsPackage "Depth";
needsPackage "SimplicialComplexes";

-------------------
-- Exports
-------------------
export {isShellable,
        isShelling,
        isSimplex,
        hVector,
        shellingOrder};

-------------------
-- Exported Code
-------------------

-- Determines if a pure simplicial complex is shellable.
isShellable = method(TypicalValue => Boolean);
isShellable (SimplicialComplex) := (S) -> (
    shellingOrder(S) != {}
);

-- Determines if a list of equidimensional faces is a shelling.
isShelling = method(TypicalValue => Boolean);
isShelling (List) := (L) -> (
    -- TODO
    -- recall: a set of equidimensional faces F_0, ..., F_k is
    --         a shelling order if for 2 <= i < k the set
    --         sc(F_0..F_i) - sc(F_0..F_(i-1)) has a unique minimal
    --         element with respect to inclusion.
    
    -- compute s0 & f0 outside for i = 0;
    -- in each iteration, put s1 & f1 in s0 & f0 before loop
    -- thus only s1 & f1 need be recomputed each loop
    -- for i from 1 to #L - 1 do (
    --    s0 = simplicialComplex take(L, i-1);
    --    s1 = simplicialComplex take(L, i);
    --    f0 = flatten for i from 0 to dim s0 - 1 list flatten entries faces(i, s0);
    --    f1 = flatten for i from 0 to dim s1 - 1 list flatten entries faces(i, s1);
    --    di = toList(set(f1) - set(f0));  
    --    ta = tally flatten apply(di, degree);
    --    if ta_(min keys ta) != 1 then return false;
    -- );
    false
);

-- Determines if a simplicial complex is (isomorphic to) a simplex.
isSimplex = method(TypicalValue => Boolean);
isSimplex (SimplicialComplex) := (S) -> (
    #flatten entries facets S <= 1
);

-- Determines the hVector of the Stanley-Reisner ideal of a simplicial complex.
hVector = method(TypicalValue => List);
hVector (SimplicialComplex) := (S) -> (
    flatten entries sub(last coefficients numerator reduceHilbert hilbertSeries ideal S, ZZ)
);

-- Attempts to find a shelling order of a pure simplicial complex.
shellingOrder = method(TypicalValue => List);
shellingOrder (SimplicialComplex) := (S) -> (
    --------------
    -- Easy checks
    --------------
    -- not pure => not pure shellable
    if not isPure S then return {};
    -- not CM => not shellable
    if not isCM quotient ideal S then return {};
    -- negatives in the h-Vector => not shellable
    if any(hVector S, i -> i<0) then return {};
    -- simplexes are nice
    if isSimplex S then return flatten entries facets S;

    --------------
    -- Naive build
    --------------
    -- TODO
    -- build up a shelling of S, pruning where possible
    -- remember that only the newest additions "shellosity"
    -- needs to be checked; i.e., it has a unique minimal
    -- element in the intersection
    {}
);

-------------------
-- Local-Only Code
-------------------

-------------------
-- Documentation
-------------------
beginDocumentation()
doc ///
    Key
        SimplicialDecomposability
    Headline
        Pure k-Decomposability for simplicial complexes.
    Description
        Text
            Determines pure k-Decomposability (including shellability) for simplicial complexes.
///

doc ///
    Key
        isShellable
        (isShellable, SimplicialComplex)
    Headline
        determines if a simplicial complex is (pure) shellable or not
    Usage
        isShellable S
    Inputs
        S:SimplicialComplex
    Outputs
        B:Boolean
            true if and only if {\tt S} is (pure) shellable
    Description
        Text
            This function currently uses the naive approach of checking all permutations of the facets.
        Example
            R = QQ[a,b,c,d,e];
            isShellable simplicialComplex {a*b*c*d*e}
            isShellable simplicialComplex {a*b*c,c*d*e}
            isShellable simplicialComplex {a*b*c,b*c*d,c*d*e}
///

doc ///
    Key
        isShelling
        (isShelling, List)
    Headline
        determines if a list of equidimensional faces is a shelling
    Usage
        isShelling L
    Inputs
        L:List
    Outputs
        B:Boolean
            true if and only if {\tt L} is (pure) shelling
    Description
        Text
            Determines if a list of equidimensional faces is a shelling of the simplicial complex generated by the faces.
        Example
            R = QQ[a,b,c,d,e];
            isShelling {a*b*c, c*d*e}
            isShelling {a*b*c, b*c*d, c*d*e}
///

doc ///
    Key
        isSimplex
        (isSimplex, SimplicialComplex)
    Headline
        determines if a simplicial complex is simplex
    Usage
        isSimplex S
    Inputs
        S:SimplicialComplex
    Outputs
        B:Boolean
            true if and only if {\tt S} is simplex
    Description
        Example
            R = QQ[a,b,c,d];
            isSimplex simplicialComplex {a*b*c*d}
            isSimplex simplicialComplex {a*b}
            isSimplex simplicialComplex {a*b,c*d}
///

doc ///
    Key
        hVector
        (hVector, SimplicialComplex)
    Headline
        determines the h-Vector of a simplicial complex
    Usage
        hVector S
    Inputs
        S:SimplicialComplex
    Outputs
        h:List
            the h-Vector of {\tt S}
    Description
        Example
            R = QQ[a,b,c,d];
            hVector simplicialComplex {a*b*c,d}
    SeeAlso
            fVector
///

doc ///
    Key
        shellingOrder
        (shellingOrder, SimplicialComplex)
    Headline
        finds a shelling of a pure simplicial complex, if one exists
    Usage
        L = shellingOrder S
    Inputs
        S:SimplicialComplex
    Outputs
        L:List
            a shelling order of the facets of {\tt S}
    Description
        Example
            R = QQ[a,b,c,d,e];
            shellingOrder simplicialComplex {a*b*c*d*e}
            shellingOrder simplicialComplex {a*b*c, b*c*d, c*d*e}
            shellingOrder simplicialComplex {a*b*c, c*d*e}
///

end
-- Happy Happy Joy Joy!
