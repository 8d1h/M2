newPackage(
             "FiniteFieldExperiments",
             Version => "0.1", 
	     Date => "14.01.2010",
     	     Authors => {{Name => "Hans-Christian Graf v. Bothmer", 
	       Email => "bothmer@math.uni-hannover.de", 
	       HomePage => "http://www.crcg.de/wiki/Hans-Christian_Graf_v._Bothmer"
	       }},
             Headline => "A Quick and Dirty Irreducibility Test",
     	     DebuggingMode => true
             )
needs"genericMatrix.m2"
needs"genericPowerMatrix.m2"

export {
     Experiment,
     numCoeff,	   	
     makeObject,       
     stratProp,     	
     savePoint,        
     codimTangent, 
     bettiSyzExperiment,    
     doExperiment,
     statString,
     statistic,
     statistics,
     points
     }

----------
-- ToDo --
----------

-- numSyzExperiment

----------
----------
----------

-- need to be able to sort booleans
Boolean ? Boolean := (x,y) -> (
     if x==y then return symbol ==;
     if x==true and y==false then return symbol <;
     if x==false and y==true then return symbol >;
     )

-- Experiment Type
Experiment = new Type of MutableHashTable

new Experiment from FunctionClosure := 
   (MutableHashTable,f) -> new MutableHashTable from {global userFunctions => f}

-- need an ideal over ZZ
new Experiment from Ideal := (MutableHashTable,I) -> (
     idealFunctions := (K) -> (
	  R := K[gens ring I];
	  IR := sub(I,R);
	  JR := jacobian IR;
	  numCoeff := #(gens R);
	  makeObject := (r) -> (
     	       Ir := sub(I,r);
     	       --F := res(coker Mr,LengthLimit=>2);     
     	       {Ir==0,r}
     	  );
          -- this code should return the property by which the 
     	  -- seach space shall be stratified
     	  -- obj: a object as generated by makeObject
     	  stratProp := (obj) -> obj#0;
     	  -- this code should return, wether a found object
     	  -- is interesting enough to be stored for later use
     	  savePoint := (obj) -> (stratProp(obj)==true);
     	  -- this code sould return, the codimension of the
     	  -- tangentspace of the stratum in which the object lies
     	  codimTangent := (obj) -> if obj#0 then rank(sub(JR,obj#1));
     	  return {
	       global numCoeff => numCoeff,	   	-- this must be provided
	       global makeObject => makeObject,     	-- this must be provided
	       global stratProp => stratProp,     	-- not necessary
	       global savePoint => savePoint,     	-- not necessary
	       global codimTangent => codimTangent 	-- not necessary
     	       }
	  );
     new Experiment from idealFunctions
     )

-- erase 2 first lines of betti table and convert into a string
smallBetti = (B) -> (
     N = net betti B;
     toString stack apply(#N-2,i->N#(i+2))
     )


-- Experiment that chooses random matrices
-- and stratifies by the betti tableau of the syzygies
bettiSyzExperiment = (F,G) -> (
     bettiFunctions := (K) -> (
          -- local variables for this field
	  R := K[gens ring F,SkewCommutative=>not isCommutative ring F];
	  BC := K[b,c,Degrees=>{0,0}];
	  RBC := BC[gens ring F,SkewCommutative=>not isCommutative R,Join=>false];
	  -- generic Matrix with b^i powers
	  MB := genericPowerMatrix(sub(F,RBC),sub(G,RBC),b);
	  -- maximal exponent of b
     	  numCoeff := max apply(flatten entries flatten(
		    (coefficients(flatten MB))#1),m-> sum flatten exponents sub(m,BC));
	  A:=K[a_1..a_(numCoeff+1),Degrees=>{(numCoeff+1):0}];
     	  RA := A[gens R,SkewCommutative => not isCommutative R, Join=>false];
     	  MA := genericMatrix(sub(F,RA),sub(G,RA),a_1);
     	  makeObject := (r) -> (
     	       Mr := sub(MA,sub(vars RA,R)|sub(r|matrix{{0_K}},R));
     	       res(coker Mr,LengthLimit=>2)
     	       --chainComplex{Mr,super basis(2,ker Mr)}
     	       );
     	  -- this code should return the property by which the 
     	  -- seach space shall be stratified
     	  -- obj: a object as generated by makeObject
     	  stratProp := (obj) -> smallBetti obj;
     	  -- this code should return, wether a found object
     	  -- is interesting enough to be stored for later use
     	  -- savePoint := (obj) -> (stratProp(obj)>2);
     	  -- this code sould return, the codimension of the
     	  -- tangentspace of the stratum in which the object lies
     	  codimTangent := (obj) -> (
     	       use BC;
     	       MC := genericPowerMatrix(sub(obj_1,RBC),sub(obj_2,RBC),c);
     	       --   (obj.dd_1 + eps*MA) * (obj.dd_2 + eps*MB) 
     	       -- =  obj.dd_1*obj.dd_1 + eps*(MA*obj.dd_2+obj.dd_1*MB) + eps^2*...  
     	       betti (m = sub(flatten(		    
			coefficients(
			 flatten (MB*sub(obj.dd_2,RBC)+sub(obj.dd_1,RBC)*MC)
			 )
		    )#1,BC));
               coeffB = sub((coefficients(m,Variables=>{b}))#1,K);
	       coeffC = sub((coefficients(m,Variables=>{c}))#1,K);
	       rank (coeffB * syz coeffC)
     	       );
     	  return {
	       global numCoeff => numCoeff,	   	-- this must be provided
	       global makeObject => makeObject,     	-- this must be provided
	       global stratProp => stratProp,     	-- not necessary
	       --global savePoint => savePoint,     	-- not necessary
	       global codimTangent => codimTangent 	-- not necessary
     	       }
	  );
     new Experiment from bettiFunctions
)

-- this code is run internally before the first
-- experiment in a given characteristic
initCharInternal = (ex,prime) -> (
     K = ZZ/prime;
     ex#prime = new MutableHashTable from ex.userFunctions(K);
     ex#prime.K = K;
     ex#prime.points = new MutableList;
     ex#prime.statistic = new MutableHashTable;
     ex#prime.numTrials = 0;
     -- get user defined thing for this characteristic
     )

-- isInteresting say wether to count an object, when
     
-- increase the value of a key in a hashtable by 1 if it
-- exists. If not create it with start value 1     
inc = (h,key) -> if h#?key then h#key = h#key+1 else h#key = 1
          
-- this Variable contains the number of seconds between
-- two prints
timeStep = 1;
	  
-- this funktion actually starts experiments
doExperiment = (ex,p,trials) -> (
     printTime := cpuTime();
     back := "";
     print "";
     doSave := null;
     if not ex#?p then initCharInternal(ex,p);
     for i from 1 to trials do (
	  ct := cpuTime();
	  if ct>printTime then (
	       s := toString stack(toString i,"",statString(ex,p));
	       print (back|s);
	       back = backspaces(#s+1);
	       printTime = ct + timeStep;
	       );
	  r := random(ex#p.K^1,ex#p.K^(ex#p.numCoeff));
	  obj := ex#p.makeObject(r);
	  if ex#p.?stratProp then sP = ex#p.stratProp(obj) else sP = null;
	  if ex#p.?codimTangent then cT = ex#p.codimTangent(obj) else cT = null;
	  inc(ex#p.statistic,(sP,cT));
	  if not ex#p.?savePoint then doSave = false else doSave = ex#p.savePoint(obj);
	  if doSave then (
	       print r;
	       ex#p.points#(#ex#p.points) = r
	       );
	  ex#p.numTrials = ex#p.numTrials+1;
	  );
     s := toString stack(toString trials,"",statString(ex,p));
     print (back|s);
     )

-- add spaces to the left, to make string s of lenth l
spacesLeft = (s,l) -> (
     if #s >= l then s else (
	  fold((a,b)->(a|b),apply(l-#s,i->" "))|s
	  )
     )

spacesRight = (s,l) -> (
     if #s >= l then s else (
	  s|fold((a,b)->(a|b),apply(l-#s,i->" "))
	  )
     )

backspaces = (n) -> (
     fold((a,b)->(a|b),n:ascii(8))
     )

format0 = (x) -> (
     rx = round(2,x);
     ax = abs rx;
     sign = if rx<0 then "-" else "";
     xint = floor(ax);
     xfrac = ax - xint;
     s = toString round(100+ax*100);
     ss = spacesLeft(sign|toString xint|"."|s#1|s#2,7)
     )

statString = (ex,p) -> (
     if ex#?p then (
	  if ex#p.?statistic then (
	       Ls := apply(
		    sort keys ex#p.statistic
		    ,k->(
			 if (k#1 =!= null) then(
			      success := ex#p.statistic#k;
			      err := 2*sqrt(success*1.0);
			      d := ex#p.numTrials/p^(k#1)*1.0;
			      (
				   spacesRight(toString k#0,12)|
				   spacesLeft(toString k#1,4)|
				   spacesLeft(toString(success),7)|
			      	   format0((success-err)/d)|
			      	   format0((success+err)/d)|
				   spacesLeft(toString round(0,success/d),5)
			      )
			      ) else (
				   spacesRight(toString k,10)|
				   spacesLeft(toString ex#p.statistic#k,7)
			      )
			      
			 ));
	       toString stack Ls
	       )
	  )
     )

statistics = (ex,p) -> (
     print statString(ex,p)
     )

points = (ex,p) -> (
     toList ex#p.points
     )

beginDocumentation()

     doc ///
     Key
       FiniteFieldExperiments
     Headline
       Bookkeeping for experiments over finite fields
     Description
       Text
         This package helps to set up finite field experiments
	 and does all the necessary bookkeeping, such as
	 counting sucesses, remembering interesting points,
	 saving and loading experiments, statistical interpretation
	 of experimental results.
       Example
     Caveat
     SeeAlso
     ///

     doc ///
     Key
       doExperiment
     Headline
       run experiment for a number of trials
     Usage
       doExperiment(ex,p,m)
     Inputs
       ex:Experiment
          an experiment setup
       p:ZZ
          Prime over which the new trails should be carried out
       m:ZZ
          The number of trials the experiment should be done
     Consequences
       ex#p.points and ex#p.statistic will be changed. ex#p will be
       created if it does not yet exist.
     Description
       Text
         m random points with ex#p.numCoeff coefficients are
         made into objects using the function ex#p.makeObjekt.
         For all of them ex#p.stratProperty and ex#p.codimTangent are
         calculated and counted in ex#p.statistic. For those objects wher ex#p.savePoint is 
         true to defining point is saved in ex#p.points.
       Example
       	 R = ZZ[x_0..x_4]
 	 F = random(2,R)
	 G = random(3,R);
	 H = random(4,R);
	 I = ideal(F*H,G*H);
	 exI = new Experiment from I
	 doExperiment(exI,5,100)
	 doExperiment(exI,5,100)
     Caveat
     SeeAlso
 
     /// 
  
  end
  ---
  
        
     ///

end
--- 
     doc ///
     Key
     Headline
     Usage
     Inputs
     Outputs
     Consequences
     Description
       Text
       Example
     Caveat
     SeeAlso
     ///

     doc ///
     Key
     Headline
     Usage
     Inputs
     Outputs
     Consequences
     Description
       Text
       Example
     Caveat
     SeeAlso
     ///

     TEST ///
     -- test code and assertions here
     -- may have as many TEST sections as needed
     ///

end
-----

uninstallPackage"FiniteFieldExperiments"
restart
installPackage"FiniteFieldExperiments"
viewHelp

restart
loadPackage"FiniteFieldExperiments"

K = ZZ/5
E = K[e_0..e_3,SkewCommutative=>true]
ex = bettiSyzExperiment(E^{2:0},E^{3:-1})
betti res coker random(E^{2:0},E^{3:-1})

doExperiment(ex,2,100)
peek ex#2
e
betti(F=res coker random(E^{0},E^{-1,-2}))
help BettiTally

methods
N= net betti F
smallBetti F
#N

restart
loadPackage"FiniteFieldExperiments"

R = ZZ[x,y,z]
I = ideal(x*y,x*z)
e = new Experiment from I
peek e

time doExperiment(e,7,10)
peek ((e#7).statistic)
peek e#7 
((e#7)#((keys e#7)#3))
keys e#7
points(e,7)


statistics(e,7)

--------

restart
loadPackage"FiniteFieldExperiments"
n=3;k=3;l=3;
load"exteriorSyzExperimentPower.m2"

ex = new Experiment from userFunctions

time doExperiment(ex,2,1000)

restart
load"FiniteFieldExperiments.m2"

-- make a new experiment
ExSyz = new Experiment from userFunctions

time doExperiment(ExSyz,3,1000)
#(ExSyz#3#points)

statistics(ExSyz,3)

peek ExSyz
peek ExSyz#3
peek ExSyz#3#statistic

time doExperiment(ExSyz,5,100)

peek ExSyz
peek ExSyz#5
peek ExSyz#5#statistic

viewHelp

---

restart
load"FiniteFieldExperiments.m2"

R = ZZ[x,y,z]
I = ideal(x*y,x*z)

e = new Experiment from I

peek e

time doExperiment(e,7,1000)

statistics(e,7)

peek e
peek e#3
peek e#3#statistic

format(2,0.3344)

------

-- this is the general (slow case)
rankJacobi = (obj) -> (
     use EAB;
     time MA = genericMatrix(sub(obj_0,EAB),sub(obj_1,EAB),a_1);
     time MB = genericMatrix(sub(obj_1,EAB),sub(obj_2,EAB),b_1);
     --   (obj.dd_1 + eps*MA) * (obj.dd_2 + eps*MB) 
     -- =  obj.dd_1*obj.dd_1 + eps*(MA*obj.dd_2+obj.dd_1*MB) + eps^2*...     
     time betti (I = sub(ideal mingens ideal (coefficients(flatten (MA*sub(obj.dd_2,EAB)+sub(obj.dd_1,EAB)*MB)))#1,AB));
     time J = eliminate(I,flatten entries sub(vars B,AB));
     codim sub(J,A)
     )

