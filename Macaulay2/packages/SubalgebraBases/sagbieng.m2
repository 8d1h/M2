-- Copyright 1997 by Mike Stillman and Harry Tsai

-- This file contains code to compute the sagbi basis
-- of a subalgebra of a polynomial ring.
-- Do 'help sagbi' for references.

Matrix % Ideal := (f,I) -> (
     if isHomogeneous f and isHomogeneous I then (
	  m := max degrees source f;
	  g := gb(I,DegreeLimit=>m);
          f % g)
     else f % gb I)

document { quote sagbi,
     TT "sagbi(F:Matrix, maxdeg:ZZ) --> Matrix",
     BR,NOINDENT,
     "  -- yields a matrix whose entries form
a subalgebra basis (sagbi) of the subalgebra generated by the entries of
the matrix F.",
     PARA,
     "This routine computes a sagbi basis degree by degree,
     for a graded or nongraded subalgebra.",
     EXAMPLE ///
     ///,
     "Caveats: F should be a matrix over a polynomial ring over a field,
     and NOT a quotient ring.",
     PARA,
     "References: Kapur, D., Madlener, K. (1989). A completion procedure
for computing a canonical basis of a $k$-subalgebra.
Proceedings of {\it Computers and Mathematics 89}
(eds. Kaltofen and Watt), MIT, Cambridge, June 1989.",
PARA,
"Robbiano, L., Sweedler, M. (1990). Subalgebra bases,
in W.~Bruns, A.~Simis (eds.): {\sl Commutative Algebra},
Springer Lecture Notes in Mathematics {\bf 1430}, pp.~61--87.",
PARA,
"F. Ollivier, Canonical Bases: Relations with Standard bases, finiteness
conditions and applications to tame automorphisms, in Effective Methods
in Algebraic Geometry, Castiglioncello 1990, pp. 379-400, Progress in Math.
{\bf 94} Birkhauser, Boston (1991)",
PARA,
"B. Sturmfels, Groebner bases and Convex Polytopes, Univ. Lecture Series 8,
Amer Math Soc, Providence, 1996"
     }

setMonomialOrderFlag = (R) -> (
     local tempflag;
     temp := (monoid R).Options.MonomialOrder;
     if (class temp) === Nothing then (tempflag = 0)
     else if temp === GRevLex then (tempflag = 0)
     else if temp === Lex then (tempflag = 1)
     else if temp === GLex then (tempflag = 2)
     else if (class temp) === Eliminate then (tempflag = 3)
     else if (class temp) === ProductOrder then (tempflag = 4)
     else if temp === RevLex then (tempflag = 5);
     tempflag)

submatrixByDegrees = (m,d) -> (
    want := positions(0..numgens source m - 1, 
	             i -> (degrees source m)_i === {d});
    m_want)

submatrixBelowDegree = (m,d) -> (
    want := positions(0..numgens source m - 1, 
	             i -> (degrees source m)_i < {d});
    m_want)

rowReduce = (elems, d) -> (
     -- elems is a one row matrix of polynomials, all of degree d.
     -- return a (one row) matrix whose elements are row reduced
     -- CAUTION: Only the monomial orders GRevLex, Eliminate, Lex, and RevLex
     --	     	 are supported by this routine.  The monomial orders
     --	    	 Lex and ProductOrder ARE NOT SUPPORTED.
     local RH, RtoRH, RHtoR, elemsH;
     R := ring elems;
     n := numgens R;
     M := monoid R;
     moFlag := setMonomialOrderFlag R;
     if moFlag == 5 then (
	  RH = (coefficientRing R)[Variables=>n+1, 
	       MonomialOrder => RevLex,
	       Degrees => prepend({1},M.Options.Degrees)];
	  RtoRH = map(RH,R,(vars RH)_{1..n});
     	  RHtoR = map(R,RH,matrix{{1_R}} | vars R);
          elemsH = homogenize(RtoRH elems, RH_0);)
     else (
	  if moFlag == 2 then (
	       << "WARNING: GLex is an unstable order for rowReduce" << endl)
	  else if moFlag == 4 then (
     	       RH = (coefficientRing R)[Variables=>n+1, 
	       	    MonomialOrder => append(M.Options.MonomialOrder,1),
	       	    Degrees => append(M.Options.Degrees,{1})])
	  else (
     	       RH = (coefficientRing R)[Variables=>n+1, 
	       	    MonomialOrder => M.Options.MonomialOrder,
	       	    Degrees => append(M.Options.Degrees,{1})]);
     	  RtoRH = map(RH,R,(vars RH)_{0..n-1});
     	  RHtoR = map(R,RH,vars R | matrix{{1_R}});
     	  elemsH = homogenize(RtoRH elems, RH_n););
     RHtoR gens gb(elemsH, DegreeLimit=>d))

TEST ///
S = QQ[a,b,c]
m = matrix{{a^2, a^2+a, b^2+a^2+1, a^2+b^2+3, a*b+a}}
rowReduce(m,2)
///

---------------------------------
-- Inhomogeneous SAGBI bases ----
---------------------------------
sagbi = method()
sagbi(Matrix,ZZ) := (Gens, maxnloops) -> (
     --local R, G, S, RS, RStoS, Gmap, inGmap, J;
     --local d, maxdeg, nloops, Pending;
     R = ring Gens;
     MOflag := setMonomialOrderFlag R;
     if MOflag == 3 then (
	  << "" << endl;
	  << "******************************************************" << endl;
	  << "** WARNING: ENGINE SUBDUCT NOT STABLE W/ ELIM ORDER **" << endl;
	  << "******************************************************" << endl;
	  << "" << endl;
	  );	  
     maxdeg := maxnloops;
     Pending = new MutableList from toList(maxdeg+1:{});
     insertPending := (m) -> (
	  -- append the entries of the one row matrix 'm' to Pending.
	  i := 0;
	  lodeg := (degree m_(0,0))_0;
	  while i < numgens source m do (
	      f := m_(0,i);
	      e := (degree f)_0;
	      if e < lodeg then lodeg = e;
	      Pending#e = append(Pending#e, f);
	      i = i+1;
	      ));
     lowestDegree := () -> (
	  -- returns maxdeg+1 if Pending list is empty, otherwise
	  -- returns the smallest non-empty strictly positive degree.
	  i := 0;
	  while i <= maxdeg and Pending#i === {} do i=i+1;
	  i);
     appendToBasis := (m) -> (
	  R := ring m;
	  M := monoid R;
	  G = G | m;
	  nR = numgens R;
	  nG = numgens source G;
     	  if MOflag == 5 then (
	       RS = (coefficientRing R)[quote b_1.. quote b_nG, 
	       	    quote a_1.. quote a_nR,
	       	    Degrees=>join(degrees source G, degrees source vars R),
	       	    MonomialOrder => RevLex];
	       RtoRS = map(RS,R,(vars RS)_{nG..nG+nR-1});
	       J = ideal((vars RS)_{0..nG-1} - RtoRS(leadTerm G));
	       Gmap = map(RS,RS, RtoRS(G) | (vars RS)_{nG..nG+nR-1});
     	       RStoR = map(R,RS,matrix {toList(nG:0_R)} | vars R);
	       RStoS = map(RS,RS, (vars RS)_{0..nG-1} |
		    matrix {toList(nR:0_RS)});)
   	  else (
	       if MOflag == 0 or MOflag == 3 then (NewOrder = Eliminate nR)
	       else if MOflag == 4 then (
		    NewOrder = append(M.Options.MonomialOrder,nG))
	       else (NewOrder = M.Options.MonomialOrder);
	       RS = (coefficientRing R)[quote a_1.. quote a_nR, 
	       	    quote b_1.. quote b_nG,
	       	    Degrees=>join(degrees source vars R, degrees source G),
	       	    MonomialOrder => NewOrder];
	       RtoRS = map(RS,R,(vars RS)_{0..nR-1});
	       RStoS = map(RS,RS, matrix {toList(nR:0_RS)} |
		    (vars RS)_{nR .. nR+nG-1});
	       J = ideal((vars RS)_{nR..nR+nG-1}-RtoRS(leadTerm G));
	       Gmap = map(R,RS, (vars R)_{0..nR-1} | G);
	       Gmap = map(RS,RS,(vars RS)_{0..nR-1} | RtoRS(G));
	       RStoR = map(R,RS,(vars R) | matrix {toList(nG:0_R)});
	       );
	  );
     grabLowestDegree := () -> (
	  -- assumes: lowest degree pending list is already autosubducted.
	  -- this row reduces this list, placing all of the
	  -- entries back into Pending, but then appends the lowest
	  -- degree part into the basis.
	  e := lowestDegree();
	  if e <= maxdeg then (
	       trr = timing rowReduce(matrix{Pending#e}, e);
	       timerr = trr#0;
	       << "    rowred  done in " << timerr << " seconds" << endl;
	       m = trr#1;
	       Pending#e = {};
	       insertPending m;
	       e = lowestDegree();
	       numnewsagbi = #Pending#e;
	       timeapp = (timing appendToBasis matrix{Pending#e})#0;
	       << "    append  done in " << timeapp << " seconds" << endl;
	       Pending#e = {};
	       );
	  e);
     
     G = matrix(R, {{}});
     Gensmaxdeg = (max degrees source Gens)_0;
     Gens = compress submatrixBelowDegree(Gens, maxdeg+1);
     insertPending Gens;
     Pending#0 = {};
     d = grabLowestDegree();  -- initializes G 
     proplist = {{d,0,0,timeapp,timeapp,0,0,numnewsagbi}};
     d = d+1;
     nloops := d;
     isdone := false;
     while nloops <= maxnloops and not isdone do (
       ttotal := timing(
	  nloops = nloops+1;
	  << "--- degree " << d << " ----" << endl;
     	  tgbJ := timing gb(J, DegreeLimit=>d);
	  gbJ = tgbJ#1;
	  timegbJ = tgbJ#0;
	  << "    gb comp done in " << timegbJ << " seconds" << endl;
	  -- spairs = time mingens ideal selectInSubring(1, gens gbJ);
	  spairs = submatrixByDegrees(selectInSubring(1, gens gbJ), d);
	  tGmap = timing Gmap(spairs);
	  spairs = tGmap#1;
	  timeGmap = tGmap#0;
	  << "    Gmap    done in " << timeGmap << " seconds" << endl;
	  if Pending#d != {} then (
	       newgens = RtoRS(matrix{Pending#d});
	       spairs = spairs | newgens;
	       Pending#d = {};);
	  numspairs = numgens source spairs;
	  tsub = timing sendgg(ggPush spairs, ggPush Gmap, ggPush gbJ, 
		    ggsubduction);
	  timesub = tsub#0;
	  << "    subduct done in " << timesub << " seconds" << endl;
     	  tRS = timing compress RStoR(getMatrix RS);
	  timeRS = tRS#0;
	  << "    RStoR   done in " << timeRS << " seconds" << endl;
	  newguys = tRS#1;
	  if numgens source newguys > 0 
	  then (
     	       << "    GENERATORS ADDED!" << endl;
	       insertPending newguys;
	       d = grabLowestDegree();
	       << "    " << numnewsagbi << " NEW GENERATORS!" << endl;
	       )
	  else (
	       timerr = 0; 
	       timeapp = 0;
	       numnewsagbi = 0;
	       ngens := sum apply(toList Pending,i -> #i);
	       if ngens === 0 and gbJ.returnCode === 0 and d>Gensmaxdeg then (
	           isdone = true;
		   << "    SAGBI basis is FINITE!" << endl;
		   );
	      );
	      );
	 timetotal = ttotal#0;
	 << "    deg " << d << "  done in " << timetotal << " seconds" << endl;
	 timeleftover = timetotal - timegbJ - timesub - timeapp;
	 proplist = append (proplist, 
	      {d,timegbJ,timesub,timeapp,timetotal,timeleftover,
		   numspairs, numnewsagbi});
	 timeunaccount = timetotal - timegbJ - timeGmap - timesub - timeRS - 
	      timerr - timeapp;
	 << "    leftover time   " << timeunaccount << " seconds" << endl;
	 d=d+1;
	 );
     G)


